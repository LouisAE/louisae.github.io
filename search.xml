<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疯言疯语</title>
      <link href="/2023/11/47300.html"/>
      <url>/2023/11/47300.html</url>
      
        <content type="html"><![CDATA[<p>有时候啊，真的觉得自己非常无力和懦弱，即使是珍惜的事物在自己面前被破坏，被蹂躏，心里明白自己没有做错任何东西，面对那强权，却完全无法提起反抗的想法。反思百遍，我认为我们问心无愧，强权为了自己的那顶帽子，化身纣王的帮凶，给我们严重的打击。公平正义？有权有理！<strong></strong></p><p style="text-align:right"><strong>–2023.11.22 于会后</strong></p><p></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简易CMake入门</title>
      <link href="/2023/11/63520.html"/>
      <url>/2023/11/63520.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CMake">什么是CMake</h2><p>先来看看维基百科上的定义</p><blockquote><p>CMake是个一个开源的跨平台自动化建构系统</p></blockquote><p>emmmm…这每个字都能看懂，合在一起就不知道在说啥了。还是按我的理解翻译成人话吧</p><blockquote><p>CMake是一个编译辅助工具，可以根据用户的配置生成自动编译脚本</p></blockquote><h3 id="项目编译的难题">项目编译的难题</h3><p>我们初学编程的时候，大多时候只须编译一个代码文件，顶多三四个文件。这个时候手打命令行编译已经足以满足我们的需求。</p><p>然而，如果我们的技术得到了提高，开始开发一些大型项目的时候，可能动辄需要编译成百上千个文件，这个时候如果还需要手动一个个文件编译，那一定是地狱般的体验。</p><p>众所周知，程序员是个非常懒惰的群体，一旦遇到重复性的或者麻烦的东西，他们总希望能写一个程序或者脚本来解决这些东西。</p><h3 id="从-make-到-CMake">从 make 到 CMake</h3><p>于是 make（是的，还没轮到 CMake 登场）诞生了。这个程序允许用户事先编写一个叫做 Makefile 的文件，在里面指定代码文件目录、编译器、外部库、编译选项等内容，然后使用 make 命令一键编译。</p><p>来看看<a href="https://github.com/karottc/linux-0.11/raw/master/Makefile">一个手写的Makefile</a>。</p><p>这是 Linus Torvalds 给 Linux 0.11 的内核源码编写的 Makefile，可以很清楚看到里面指定了as、gcc作为汇编和c的编译器，ld作为连接器，并且明确了需要编译哪些模块，输出哪些中间文件，以及如何连接成可执行文件。</p><p>看起来 make 是个十分不错的东西，然而从上面的文件可以看出，Makefile实际上还是非常复杂，举个例子，假设我在开发一个跨平台的程序，就得针对这两个平台各自写一个Makefile，分别指定对应的编译器。如果我增加了几个代码文件，也得把它们逐个添加进Makefile。如果我把我的代码发布给用户，让用户编译，也可能因为用户的操作系统环境、使用的编译器不同等因素导致编译失败并且难以发现错误。</p><p>于是，在 make 之上，人们又开发出了多种生成 Makefile 的工具。例如 GNU 的 autoconf，Qt 的 qmake，以及我们的主角 CMake。利用这些工具，可以通过简单的配置，在不同平台、不同环境中方便地生成 Makefile。</p><h2 id="CMake安装">CMake安装</h2><p>从<a href="https://cmake.org/download/">这里</a>下载msi安装包并安装即可</p><h2 id="CMake用法">CMake用法</h2><p>CMake的用法很简单，写一个名为<code>CMakeLists.txt</code>的配置文件，再用 CMake 跑一下，就可以生成我们想要的 makefile。</p><h3 id="配置文件的内容">配置文件的内容</h3><p>先想想，要编译一个程序，我们需要什么东西？编译器及连接器、源文件、外部库。若没有指定，CMake 会自动查找编译器。因此，我们可以仅指定源文件和外部库。</p><p>CMakeLists.txt 类似一个脚本，由一个个“函数”以及可能存在的分支语句组成。因为是简易入门，因此只记录几个简单的函数，不去管那些高级的写法，一开始的话，够用就行了。</p><h3 id="常用函数">常用函数</h3><p>来看一个简单的例子。</p><pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.15</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>SampleProject<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. SRC_FILES<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token string">"./include"</span><span class="token punctuation">)</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token string">"./lib"</span><span class="token punctuation">)</span><span class="token keyword">link_libraries</span><span class="token punctuation">(</span><span class="token string">"libcurl.a"</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC_FILES<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a href="https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html"><code>cmake_minimun_required</code></a></p><p>用法：<code>cmake_minimun_reauired(VERSION &lt;min&gt;)</code></p><p>指定执行这个脚本的 CMake 的最小版本，一般用于兼容，对初学者而言并不重要</p><p><a href="https://cmake.org/cmake/help/latest/command/project.html"><code>project</code></a></p><p>用法：<code>project(&lt;PROJECT-NAME&gt;)</code></p><p>指定项目名称，CMake会自动把指定的名称存到<code>PROJECT_NAME</code>变量中</p><p><a href="https://cmake.org/cmake/help/latest/command/aux_source_directory.html"><code>aux_source_directory</code></a></p><p>用法：<code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code></p><p>把&lt;dir&gt;所指定的目录中的所有源代码文件添加到&lt;variable&gt;所指定的变量中</p><p><a href="https://cmake.org/cmake/help/latest/command/include_directories.html"><code>include_directories</code></a></p><p>用法：<code>include_directories(dir1 [dir2 ...])</code></p><p>指定一个或多个包含目录，也就是头文件所在的目录。一般提供相对目录，也就是相对于CMakeLists.txt所在文件夹的目录。</p><p><a href="https://cmake.org/cmake/help/latest/command/link_directories.html"><code>link_directories</code></a></p><p>用法：<code>link_directories(directory1 [directory2 ...])</code></p><p>指定一个或多个包含外部库的目录</p><p><a href="https://cmake.org/cmake/help/latest/command/link_libraries.html"><code>link_libraries</code></a></p><p>用法：<code>link_libraries([item1 [item2 ...])</code></p><p>指定一个或多个要连接的库，填写库的文件名</p><p><a href="https://cmake.org/cmake/help/latest/command/add_executable.html"><code>add_executable</code></a></p><p>用法：<code>add_executable(&lt;name&gt; [source1] [source2 ...])</code></p><p>声明这个项目要输出的其中一个可执行文件，并且指定它的名称，以及对应的一个或多个源代码文件。</p><p>明白了这些函数的用法以后，就理解这个CMakeLists在做的事情了：</p><ul><li>指定最小 CMake 版本为3.15</li><li>把当前目录（CMakeLists.txt）所在目录中所有源代码文件的名称存入 SRC_FILES 中</li><li>指定额外的头文件（比如外部库的）的包含目录是当前目录下的 include 文件夹</li><li>指定外部库所在的目录是当前目录下的 lib 文件夹</li><li>指定要连接 libcurl 这个库，文件名是 libcurl.a</li><li>声明要输出一个可执行文件，名称在 <code>PROJECT_NAME</code> 变量中，对应的源代码文件名称在 <code>SRC_FILES</code>中</li></ul><h3 id="编译">编译</h3><p>写好配置文件后，把它放到源代码所在目录，在这个目录启动命令行执行<code>cmake .</code>，CMake会自动生成编译所需要的各种文件。然后我们再根据对应的编译器，执行相关的编译操作。如 MinGW 在 Windows 上使用 <code>mingw32-make</code>指令。</p><p>如果在Windows上使用MinGW，CMake可能会报错找不到编译器，这是因为CMake在Windows上默认使用MSVC编译器，只需执行的时候加上参数，也就是<code>cmake -G "MinGW Makefiles" .</code>就可以了。</p><p>这样，就可以编译一个不包含子项目，要连接外部库的程序了。顺带一提，如果不需要连接外部库，上述配置文件中和外部库相关的函数就都不需要了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 对象的内存模型</title>
      <link href="/2023/11/11245.html"/>
      <url>/2023/11/11245.html</url>
      
        <content type="html"><![CDATA[<h2 id="一般对象和子类对象">一般对象和子类对象</h2><h3 id="说明">说明</h3><p>一般对象的内存中仅包含其成员变量而不包含成员函数，子类对象中包括父类的成员变量和子类自己的成员变量。</p><h3 id="代码验证">代码验证</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// SampleClass.h</span><span class="token keyword">class</span> <span class="token class-name">SampleClass</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">int</span> pnum<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtend</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">getExNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">int</span> expnum<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> exnum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// main.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"SampleClass.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>SampleClass sc<span class="token punctuation">;</span>SampleClassExtend sce<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sce<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>控制台输出：</p><blockquote><p>8</p><p>16</p></blockquote><p>父类对象有2个整型成员变量，因此占<code>4 * 2 = 8</code>个字节。子类对象也包含2个整型成员变量，共占用<code>4 * 2 + 8 = 16</code>个字节。</p><h2 id="有虚函数的类对象及其子类对象，以及覆盖了父类的虚函数的子类对象">有虚函数的类对象及其子类对象，以及覆盖了父类的虚函数的子类对象</h2><h3 id="说明-2">说明</h3><p>虚函数的实现要通过虚函数表，因此有虚函数的类对象应当包含一个虚函数表指针（在64位操作系统上是8字节）。同理，其子类也包括一个虚函数表指针。</p><p>虚函数表的特征如下</p><ul><li>若子类没有覆盖父类的虚函数，则子类和父类共用同一个虚函数表。</li><li>若子类覆盖了任意一个父类的虚函数，或者子类定义了新的虚函数，那么子类将拥有自己的虚函数表，其中对应的函数指针被覆盖。其它成员和普通的类对象及其子类对象一致。</li></ul><h3 id="验证代码和环境">验证代码和环境</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// SampleClass.h</span><span class="token keyword">class</span> <span class="token class-name">SampleClass</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtend</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">ExtraVirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtend2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>注：以上各成员函数的定义在此省略不写。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// main.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"SampleClass.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SampleClass sc<span class="token punctuation">;</span>SampleClassExtend sce<span class="token punctuation">;</span>SampleClassExtend2 sce2<span class="token punctuation">;</span>sc<span class="token punctuation">.</span><span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sce<span class="token punctuation">.</span><span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sce<span class="token punctuation">.</span><span class="token function">ExtraVirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sce2<span class="token punctuation">.</span><span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>环境：</p><p>Windows 11 22H2 x64 with Intel Core i5-11300H</p><p>编译器：</p><p>g++ 13.1.0</p></blockquote><h3 id="内存占用验证">内存占用验证</h3><p>通过sizeof获取SampleClass、SampleClassExtend、SampleClassExtend2的大小，得到</p><blockquote><p>16</p><p>24</p><p>16</p></blockquote><p>这里涉及到一个内存对齐的问题（可能）。如果对象的实际占用不是8的倍数，会被自动填充为8的倍数。例如SampleClassExtend的实际大小为<code>8 + 2 * 4 + 1 = 17</code>，被填充为24。</p><h3 id="虚函数表验证">虚函数表验证</h3><p>我个人强烈反对使用指针转换符对指针进行各类乱七八糟、甚至是非法的转换，更不要说拿这种指针来当作函数指针以试图调用某个函数了。这样做很可能让人染上滥用指针类型转换的毛病。因此，不通过所谓取指针打印的方法，而通过反汇编的方法直接查看内存来得到结论。</p><p>使用x64dbg调试编译出来的二进制程序test.exe，发现直接查看汇编代码比较难懂，于是先使用ida反汇编，来对照实际的汇编代码。</p><p>如图，左图为x64dbg的截图，右图为ida的截图。重要的语句已经用黄色记号标出。</p><p><img src="https://cdn.ncmc.me/2023/11/00/00.jpg" alt="汇编代码"></p><p>标黄的语句中，第一第二句分别获取SampleClass和它的子类SampleClassExtended的虚函数表地址。</p><p>对照我们的源代码可以看出，第4-6句分别调用了父类的虚函数、 子类覆盖的虚函数、 子类新定义的虚函数子类未覆盖的虚函数。</p><p>从第一、二句可以看出，程序只加载了SampleClass和SampleClassExtend的虚函数表。对比第四句和第六句，可以看出执行的实际上是同一个函数<code>SampleClass::VirtualMethod</code>，因此得出结论一：若子类未覆盖任何虚函数，则和父类共用同一个虚函数表，且执行父类的虚函数。</p><p>对照汇编代码和结论一即可得到结论二：覆盖了父类虚函数的子类对象拥有自己的虚函数表。</p><p>下面来验证被执行的四个函数确实是通过虚函数表查出来的。对照x64dbg提供的汇编代码，我们知道，SampleClass的虚函数表地址为：<code>ds:[7FF7B08D4440] + 10h</code>，SampleClassExtend的虚函数表地址为：<code>ds:[7FF7B08D4450] + 10h</code>。使用内置的计算器计算出实际的地址并跳转到对应内存。</p><p><img src="https://cdn.ncmc.me/2023/11/00/01.jpg" alt="计算器"><img src="https://cdn.ncmc.me/2023/11/00/02.jpg" alt="计算器"><img src="https://cdn.ncmc.me/2023/11/00/03.jpg" alt="内存"></p><p>内存图中，每行包含16个字节，因此可以存储两个指针，可以看出SampleClass包括两个虚函数。Intel处理器使用<a href="https://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F">小端序</a> ，据此可以读出第一个虚函数的地址为<code>7FF7B08D1450</code>，与代码中显示的完全一致。其它三个函数可以如法炮制，就不画蛇添足了。这里也可以看出SampleClassExtend有三个虚函数，没覆盖的父类虚函数指针原样保存在虚函数表中。</p><h2 id="多继承和虚继承">多继承和虚继承</h2><p>马克思主义认为，要结合理论和实践，实践可以推动理论。因此，让我们从事实来推出理论。</p><p>编写以下代码</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// SampleClass.h</span><span class="token keyword">class</span> <span class="token class-name">SampleClass</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtend1</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">VirtualMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2147483647</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtend2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SampleClassExtendExtend</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SampleClassExtend1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">SampleClassExtend2</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">long</span> <span class="token keyword">long</span> ll <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">normalExtend</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SampleClass</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">long</span> <span class="token keyword">long</span> ll <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// main.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"SampleClass.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SampleClass sc<span class="token punctuation">;</span>SampleClassExtend1 sce1<span class="token punctuation">;</span>SampleClassExtendExtend scee<span class="token punctuation">;</span>normalExtend ne<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译以上代码，使用x64dbg调试，直接找到sc、sce1、scee的地址并转到内存，如下图<img src="https://cdn.ncmc.me/2023/11/00/04.jpg" alt="内存"></p><p>三个对象的内存已经用红线分开，<strong>从下到上</strong>分别为sc、sce1、scee</p><p>sc的内容：</p><ul><li>7ff69ba34820 这是SampleClass的虚函数表的地址</li><li>…01 这是sc的数据，前面的是内存中的残余随机数据</li></ul><p>sce1的内容：</p><ul><li>7ff6b9a34890 这是SampleClassExtend1的虚函数表的地址</li><li>…01 这是从父类继承来的数据</li><li>7ff6b9a34868 等价于上面结尾为4890的地址</li><li>…7fffffff int 类型的2147483647，是sce1的数据</li></ul><p>scee的内容：</p><ul><li><p>7ff69ba348f8 等价于上面结尾为4890的地址</p></li><li><p>…01 SampleClass继承来的数据</p></li><li><p>7ff69ba348d8 未知内容，此为非法地址</p></li><li><p>000000000064 long long类型的100，scee自己的数据</p></li><li><p>7ff69ba348b8 等价于上面结尾为4890的地址</p></li><li><p>…7fffffff 从sce1继承来的数据</p></li></ul><p>由此我们可以直接观察得到结论。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的成员函数指针</title>
      <link href="/2023/10/27019.html"/>
      <url>/2023/10/27019.html</url>
      
        <content type="html"><![CDATA[<p>最近学习的过程中，碰到了这样一个代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">SampleClass sc<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span>SampleClass<span class="token double-colon punctuation">::</span><span class="token operator">*</span>fptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>SampleClass<span class="token double-colon punctuation">::</span>Method<span class="token punctuation">;</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token operator">*</span>fptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>刚看见这个代码的时候我是很迷惑的，并且理所当然地认为这代码会编译出错。因为SampleClass类中并没有一个叫做fptr1的成员。然而实际测试这个代码却正确编译并且执行了sc对象的Method。</p><p>谷歌了一波，发现这是一种叫做“公有成员函数指针“的东西。看过网友们的解释后再看变量的定义，才发现它十分特殊。</p><p>首先，从定义上看，fptr1不同于一般的函数指针，它的定义中绑定了一个类。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 一般函数指针</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>funcptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 成员函数指针</span><span class="token keyword">void</span> <span class="token punctuation">(</span>MyClass<span class="token double-colon punctuation">::</span><span class="token operator">*</span>funcptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种定义的格式使我一度误以为这一句在运行时给类添加了成员，并且感到大受震撼。然而这行定义的意义是：定义一个名为fptr1的函数指针，它只能指向SampleClass类的公有成员函数。后半部分的初始化也十分特殊。SampleClass::Method并不具有实际的地址，因为它还没有被实例化。因此这个初始化的意义是：把fptr1绑定到SampleClass的成员函数Method，运行时再决定这个指针具体指向的地址。因此通过这个指针调用函数时，还需要指定它调用的函数所属的对象（上面代码中的sc）。尽管调用的格式看起来就像是访问一个成员，但实际上fptr1是个变量，而非SampleClass的成员。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合及枚举、特殊指针、流</title>
      <link href="/2023/09/13518.html"/>
      <url>/2023/09/13518.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><p>前四章属于基础中的基础，基本上没有什么新的收获。只总结两个以前见得比较少的类型。</p><h3 id="联合union">联合<code>union</code></h3><p>这个东西在书里叫做共用体，而我已经习惯了把它叫做联合，尽管“共用体”这个名称实际上更加准确。</p><p>联合相当于一个可变类型的变量，根据需要给它赋予不同的值。我个人觉得这个功能似乎有点鸡肋，变类型的情况好像不是很常见。我遇到的可以用联合处理的问题大概也就是中英文字符串混用吧？比如需要读取一些名字，有英文名也有非英文名，像中文、日文、韩文、阿拉伯语这些文字。于是联合声明一种Name类型：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Name<span class="token punctuation">{</span>string english<span class="token punctuation">;</span>wstring others<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这样就可以同时处理各种不同编码的语言（虽然现在大家都倾向于UTF-8一把梭www）。</p><h3 id="枚举enum">枚举<code>enum</code></h3><p>这种类型是比较常用的，无论是用C++写成的Qt库，还是C语言写成的libcurl，都有用到这种类型。枚举的功能类似 C++ STL 里面的<code>map</code>，也就是映射，但是比较单一。它可以把一些标识符映射成对应的数字常量。例如，在 libcurl 项目的 curl.h 中有如下定义：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>  CURLE_OK <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  CURLE_UNSUPPORTED_PROTOCOL<span class="token punctuation">,</span>    <span class="token comment">/* 1 */</span>  CURLE_FAILED_INIT<span class="token punctuation">,</span>             <span class="token comment">/* 2 */</span>  CURLE_URL_MALFORMAT<span class="token punctuation">,</span>           <span class="token comment">/* 3 */</span>  CURLE_NOT_BUILT_IN<span class="token punctuation">,</span>            <span class="token comment">/* 4 - [was obsoleted in August 2007 for                                    7.17.0, reused in April 2011 for 7.21.5] */</span>  CURLE_COULDNT_RESOLVE_PROXY<span class="token punctuation">,</span>   <span class="token comment">/* 5 */</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>CURLcode<span class="token punctuation">;</span></code></pre><p>在这一块代码中，定义了错误码类型<code>CURLcode</code>，通过把标识符映射为错误码的方式，给各种错误定义了对应的错误码，并且和变量不同，它们是常量。如<code>CURLcode::CURLE_OK</code>等价于常数0。</p><p>注意到，这里显式地声明第一个标识符映射到0，于是默认地，后面的标识符映射到的数字依次加一。如果不作此声明，默认仍然会从0开始。</p><h2 id="智能指针">智能指针</h2><p>C++最大的特点之一是开发者可以直接通过指针操作内存，然而这一特性由于经常引发内存泄漏、段错误等严重问题，也久为人所诟病。因此STL提供了智能指针，可以缓解内存泄漏的问题，但还是无法解决某些段错误。</p><p>智能指针包括<code>unique_ptr</code>，<code>shared_ptr</code>等。由于我认为它们比较鸡肋，因此不过多总结（绝对不是想要偷懒）</p><h2 id="缓冲区溢出">缓冲区溢出</h2><p>文件的读写操作基本上很熟悉了，本来觉得没啥好总结的，但是“缓冲区”这个眼熟的词引起了我的注意。</p><p>缓冲区是为了减少磁盘读写次数而设置的一段内存空间。通过C++的某些函数写文件时，程序输出的少量数据会暂存在缓冲区，直到达到合适的大小后一次性写入磁盘。读取也类似，只不过流程相反。</p><p>过去曾经见过的“缓冲区溢出攻击”就是利用了缓冲区。其原理是：如果程序没有检查输入到缓冲区的数据大小，就可能导致输入的数据大于缓冲区容量，从而导致某些数据会溢出缓冲区，覆盖掉原本的数据或者代码。因此可以构造足够大而且包含恶意代码的数据输入含有漏洞的程序，使正常的程序运行恶意代码。（应该是）由于这个原因，诸多C++经典教程中教的如<code>scanf()</code>、<code>gets()</code>这样不检查输入大小的函数在MSVC中已经被默认禁用。</p><h2 id="参考">参考</h2><p><a href="https://www.cloudflare.com/learning/security/threats/buffer-overflow/">Cloudflare</a></p><p><a href="https://zh.wikipedia.org/zh-hans/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA">维基百科</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可执行文件的装载与进程</title>
      <link href="/2023/09/12719.html"/>
      <url>/2023/09/12719.html</url>
      
        <content type="html"><![CDATA[<p>注：本文为阅读《程序员的自我修养》第六章后所作总结</p><h2 id="内存">内存</h2><p>操作系统会给每个进程分配独立的虚拟内存空间。根据处理器的位数，每个进程能够访问的最大内存有所不同，但总物理内存的大小不受处理器位数的限制，而取决于地址线数量。</p><h2 id="装载方式">装载方式</h2><p>程序运行需要把数据和代码装入内存。为了提高内存利用效率，操作系统使用<strong>覆盖装入</strong>和<strong>页映射</strong>的方法实现<strong>动态装入</strong>，以确保读写最频繁的数据总是在内存中。覆盖装入允许同一程序不同模块共用一块内存空间，页映射则把数据以“页”为单位选择性装载到内存中，减少读写频率小的数据占用的内存。</p><h1>虚拟内存的结构</h1><p>程序被编译后，分为许多“段(Section)”。以下代码展示了一个C语言程序中包含的部分Section。</p><pre class="language-none"><code class="language-none">ubuntu@myserver:~$ readelf -S test.elf[Nr] Name              Type             Address           Offset       Size              EntSize          Flags  Link  Info  Align  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [ 1] .note.gnu.pr[...] NOTE             0000000000400270  00000270       0000000000000030  0000000000000000   A       0     0     8  [ 2] .note.gnu.bu[...] NOTE             00000000004002a0  000002a0       0000000000000024  0000000000000000   A       0     0     4  [ 3] .note.ABI-tag     NOTE             00000000004002c4  000002c4       0000000000000020  0000000000000000   A       0     0     4  [ 4] .rela.plt         RELA             00000000004002e8  000002e8       0000000000000240  0000000000000018  AI      29    20     8  [ 5] .init             PROGBITS         0000000000401000  00001000       000000000000001b  0000000000000000  AX       0     0     4  [ 6] .plt              PROGBITS         0000000000401020  00001020  ......</code></pre><p>一般而言，操作系统按页来映射内存，因此每个Section对应一个页。然而这样显然会造成内存的浪费，因为Section的大小不一定是页大小的整数倍。因此实际上，操作系统会把多个Section合成一个segment进行映射。合成的依据是这些Section的“权限”，读、写、执行等。Segment的信息保存在程序头中。</p><p>除了可执行文件本身包含的数据外，操作系统还会分配栈和堆空间给进程使用。</p><h2 id="装载过程">装载过程</h2><h3 id="Linux可执行文件">Linux可执行文件</h3><ul><li>检测可执行文件类型</li><li>检测可执行文件是否有效</li><li>配置动态链接</li><li><strong>对ELF进行映射</strong></li><li>初始化并启动进程</li></ul><h3 id="Windows-可执行文件">Windows 可执行文件</h3><p>Windows中可执行文件称作PE。和Linux类似，也是由Section和Segment组成的。不同点在于：</p><ul><li>无需考虑地址对其</li><li>使用相对虚拟地址（所谓偏移地址）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象、分层、派生</title>
      <link href="/2023/09/15822.html"/>
      <url>/2023/09/15822.html</url>
      
        <content type="html"><![CDATA[<p>注：本文为阅读《程序员的自我修养》第一章后所作总结。</p><p>书本对第一章的定位是“基础复习”，但是对我而言并不算复习，而更像是基础知识科普，或者说，是为了能读懂这本书而学习的一些新内容。这本书的作者也的确高明，虽然我过去基本上没有学习过这些内容，但也能够基本明白第一章所介绍的东西。</p><p>总的来说，我认为第一章的内容总结起来就是三点：抽象、分层、派生</p><h2 id="抽象">抽象</h2><p>操作系统通过驱动程序的方式，把实际的硬件操作抽象为接口，并提供给各类软件，程序员无需关心发送什么指令、 指令发往哪个端口等细节，可以把更多的时间花在具体功能的实现上。</p><p>内存方面则通过隔离、段映射和分页的方式，把实际的物理内存抽象为独立的内存空间，使内存的利用效率大大提高。</p><p>在CPU资源的分配方面，时间片机制让多进程同时运行得以实现，对每个进程而言，它们都独占一个抽象的CPU。每个进程中又可以分为多个线程，每个线程享有独占的寄存器和栈空间，这些独占空间同样是抽象的结果。</p><p>硬件设备本身也有抽象，如书中提到的硬盘LBA扇区编号方式，把盘面、磁道、扇区疏密等细节抽象为带编号的逻辑扇区，供操作系统读取，为开发人员提供了极大的便利。</p><p>另外，像Java、Python、.Net、Nodejs等语言，也是建立在各自的抽象框架上的。如Java有JVM虚拟机，Python是CPython解释器。</p><h2 id="分层">分层</h2><p>我认为，分层实质上是抽象的结果。下面这张图来自于书中（侵删）：<img src="https://cdn.ncmc.me/2023/09/00/00.jpg" alt="计算机软件体系结构"></p><p>操作系统把硬件抽象为供软件使用的各种接口，于是操作系统就是硬件的上一层。各种运行库给软件提供和操作系统交互的抽象接口，因此运行库成为了操作系统的上一层。所有的上层软件就通过这种分层结构井然有序地进行工作。</p><h2 id="派生">派生</h2><p>派生是指在已有的基础上，加入新的特性，形成新的东西。</p><p>第一章中一个很明显的派生的例子是线程的锁机制。总共有四种锁：信号量、互斥量、临界区、读写锁。我认为，前三种锁构成典型的派生关系。如图</p><p><img src="https://cdn.ncmc.me/2023/09/00/01.jpg" alt="锁的派生关系"></p><p>从上往下，每种锁在加入了新的特性后派生为新的锁。这和面向对象编程中类的派生十分类似。很多计算机软硬件的不断发展就是一个不断派生的过程。</p><p>最早的计算机中，处理器和内存以及各种I/O控制器连接在同一条总线上。随着硬件发展，出现了北桥、南桥等中转设备，再后来又出现了PCIe等总线结构以满足新硬件的需求。基于冯诺依曼结构，人们不断加入新的硬件，形成了现在的计算机。这种派生的思想在开发中也十分重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Visual Studio中使用libcurl</title>
      <link href="/2023/06/31156.html"/>
      <url>/2023/06/31156.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x0-前言">0x0 前言</h2><p>最近的一个C++项目中需要实现发送http请求的功能，计划使用有名的开源库libcurl来做。相关工具和代码的版本以及一些约定如下：</p><blockquote><p>Visual Studio 2022</p><p>curl 8.1.2</p><p>openssl 3.1.1</p><p>strawberryperl 5.32.1.1 x64</p><p>nasm 2.16.01 x64</p><p>curl代码的根目录是"C$"</p><p>openssl代码的根目录是"O$"</p><p>项目代码的根目录是"P$"</p></blockquote><h2 id="0x1-编译libcurl静态库和动态库">0x1 编译libcurl静态库和动态库</h2><p>先在<a href="https://github.com/curl/curl">curl的github仓库</a>获取源代码，这一步必须使用<code>git clone</code>来完成，否则没法完成后面的步骤。获取到代码后进入<code>C$\projects</code>，执行其中的generate.bat。脚本运行完成后进入<code>C$\projects\Windows\VCXX\lib</code>。其中XX和稍后要使用的Visual Studio的版本有关，根据脚本中的注释，对应关系如下：</p><blockquote><p>VC10 - Visual Studio 2010</p><p>VC11 - Visual Studio 2012</p><p>VC12 - Visual Studio 2013</p><p>VC14 - Visual Studio 2015</p><p>VC14.10 - Visual Studio 2017</p><p>VC14.30 - Visual Studio 2022</p></blockquote><p>进入目录，使用对应版本的Visual Studio打开libcurl.sln，在菜单栏选择名称为"DLL Release"的生成配置，平台选择x64。<img src="https://cdn.ncmc.me/2023/06/00/00.png" alt="选择生成配置">执行生成-&gt;生成解决方案，等待编译完成。编译完成后，进入<code>C$\build\Win64\VCXX\DLL Release</code>，可以看到生成了libcurl.dll和libcurl.lib两个文件，创建<code>P$\libs</code>文件夹，并把libcurl.lib复制到该文件夹中，再新建<code>P$\include</code>文件夹，把<code>C$\include\curl</code>复制到文件夹中。</p><p>在Visual Studio中打开“项目属性”窗口，选择“链接器”-&gt;“常规”，把<code>P$\libs</code>添加到“附加依赖项”中，选择"C\C++“-&gt;“常规”，把<code>P$\include</code>添加到"附加包含目录”。可以用相对路径，但是实测可能会出错，所以用绝对路径比较保险。</p><p>根据<a href="https://curl.se/libcurl/c/">官方文档</a>写好代码后，编译项目，编译通过。但运行的时候提示找不到libcurl.dll。把刚才编译的libcurl.dll复制到生成的exe所在的目录，就能正常运行了。</p><h2 id="0x2-让libcurl支持https">0x2 让libcurl支持https</h2><p>0x1中编译出来的libcurl不支持https，试图访问https网站时会返回<a href="https://curl.se/libcurl/c/libcurl-errors.html">错误码</a>1(不支持的协议)。为了添加https支持，需要第三方tls库的支持。这里使用openssl。</p><p>先从openssl的<a href="https://github.com/openssl/openssl/releases/">github release</a>下载openssl源代码并解压。这里不建议使用<code>git clone</code>。一方面openssl主分支的代码不断在更新，不能保证稳定性，另一方面openssl仓库占空间非常大，光是主分支就有几百MB。</p><p>编译openssl还需要用到perl和nasm，分别从<a href="https://strawberryperl.com">strawberryperl.com</a>和<a href="https://nasm.us">nasm.us</a>下载。</p><p>上述工具下载配置好（nasm需要放到PATH包括的文件夹中，似乎不会在安装时自动设置）之后，进入<code>C$\projects</code>并执行build-openssl.bat，需要输入几个参数，脚本的帮助信息写得很详细，不啰嗦。这里使用的是</p><pre class="language-none"><code class="language-none">build-openssl.bat vc14.3 x64 release D:\develop\openssl -perlpath "D:\develop\strawberryperl"</code></pre><p>编译过程大约需要二十分钟，编译好openssl后，把<code>O$\build\Win64\VC14.30\DLL Release\include\openssl</code>复制到<code>C$\include</code>。重新打开刚才的libcurl.sln，选择<code>DLL Release - DLL OpenSSL</code>配置，生成解决方案。编译完成后可以在<code>C$\build\Win64\VCXX\DLL Release - DLL OpenSSL</code>找到编译的输出文件。</p><p>像0x1中一样把libcurl.lib和libcurl.dll分别复制到两个文件夹中，libcurl就支持https网站的访问了。但编译出来的程序需要libssl-3-x64.dll和libcrypto-3-x64.dll才能正常运行，这两个文件也在<code>C$\build\Win64\VCXX\DLL Release - DLL OpenSSL</code>中，需要复制到exe所在的文件夹中才能正常运行。</p><h2 id="0x3-向libcurl提供可信的ca列表">0x3 向libcurl提供可信的ca列表</h2><p>似乎是出于安全考虑，libcurl默认的配置是不信任任何ca，当试图访问任何https网站的时候会返回错误码60(无法验证证书)，因此需要手动给libcurl提供一个可信的ca列表。在<a href="https://curl.se/ca/cacert.pem">curl官网</a>下载cacert.pem文件，放到<code>P$\</code>中。在代码中添加如下函数调用：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">curl_easy_setopt</span><span class="token punctuation">(</span>curlhandle<span class="token punctuation">,</span> CURLOPT_CAINFO<span class="token punctuation">,</span> <span class="token string">"cacert.pem"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>就可以正常访问https网站了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类与对象之析构函数</title>
      <link href="/2023/05/34611.html"/>
      <url>/2023/05/34611.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念">概念</h2><p>在对象被撤销时，清理对象的内存。然而析构函数并不能释放对象占用的内存，只是事先做一些清理的工作。</p><h2 id="语法">语法</h2><p>函数名和类名一致，以~开头，没有返回值，不带参数。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Myclass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token operator">~</span><span class="token function">Myclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//或者</span>        <span class="token comment">//~Myclass() {};</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>附注：在新版本C++中，建议使用noexcept关键字，表示析构函数不会抛出异常。如果使用新版本编译器，没有使用该关键字的析构函数会被自动加上该关键字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编中物理地址的合成方式</title>
      <link href="/2023/03/20524.html"/>
      <url>/2023/03/20524.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在自学汇编语言的同时，学校也在上“微机原理与应用”这门课。感觉学这类东西还是要结合实验，不然像现在的“微机原理”课一样，很多东西非常抽象，光看书根本无法理解。关于8086处理器对地址的处理，虽然感觉这部份应该很好理解，但是为了巩固印象，水一篇文章总结一下。</p><h2 id="8086中地址的处理方式及原因">8086中地址的处理方式及原因</h2><p>8086处理器使用 “段地址：偏移地址” 的方式表示地址。例如：073F:0000表示073F00这个物理地址，其中段地址和偏移地址都是16位的数字。事实上，8086处理器中的地址加法器会把段地址乘16，再与偏移地址相加以合成物理地址。例如073F:0005对应的物理地址是073FH * 10H + 5H = 073F5H。(H表示16进制)。</p><p>之所以用这种看起来啰哩啰唆的方式表示地址，是因为8086处理器有20根地址总线，可以传送20位地址，然而，8086处理器是16位处理器，一次只能处理16位的数据，所以要依靠两个16位的数据来间接表示20位的地址。</p><h2 id="补充">补充</h2><p>如果足够细心，就会发现这种寻址方式存在一个有趣的问题：如果偏移地址不止一个十六进制位，会出现什么情况呢？</p><p>假设有一个地址：073F:0022,按照上面的方式合成物理地址：073FH * 10H + 22H = 07412H。看起来，这个地址也可以写成0741:0002。这两种写法都是正确的。</p><p>实际上，同一个物理地址对应多个“段地址：偏移地址”。只要按照正确的法则合成物理地址，就不会出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搓一个语音唤醒</title>
      <link href="/2023/03/56157.html"/>
      <url>/2023/03/56157.html</url>
      
        <content type="html"><![CDATA[<p>（非原创，代某位卷王发送）</p><hr><p>（哈哈 这个排版 稀烂咯）</p><h2 id="目标">目标</h2><p>搓一个语音唤醒（keyword spotting），用于上课时摸鱼，老师点名时可以做出提醒，并且保留点名前后的一部分音频（毕竟还得知道为啥点你）。只需要识别名字，因此输入长度为1秒左右，约为两到四个音节，输出为两个类别的概率。计划采用简单的CNN+线性，将图输入进来卷积+池化然后激活，过两遍，采用适应性池化压缩为$图数\times1\times1$的向量，进两层线性+激活，最后输出为二维向量。</p><h2 id="首先做出图像来">首先做出图像来</h2><p>取一个音轨，使用快速傅里叶变换来将音频变成频谱图。首先，用<code>torchaudio.load来load一个.wav</code>，返回第一个参数是波形，第二个是采样率，用<code>torchaudio.transforms.MelSpectrogram(这里填上面解析出来的波形)</code>（梅尔图）。其实最好输入前做个滤波之类的预处理，我是因为训练的时候发现有大量的极大值（其他都是零点几，有几个10几的）所以用了些奇怪的函数来（就是log的一个变形），然后进行一个归一化（用的是最大最小值归一化）</p><h2 id="然后丢给神经网络，先组一个网络">然后丢给神经网络，先组一个网络</h2><p>由于没有经验，加上torch本身的教程和中文教程都大同小异地看不懂，所以一边摸索一边做（但是笔记是写完才做的。。。所以基本上忘记踩了什么坑了 悲）<br>aF采用elu函数（变形的泄露relu），卷积层1为<u>1层入4层出7核格宽</u>，经过(2,2)的最大池化，卷积层2为<u>4层入6层出5核格宽</u>，经过AdaptiveMaxPool2d变为$6\times1\times1$向量，线性层1<u>输入6输出8</u>，线性层2<u>输入8输出2</u>，net本身结构为</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token operator">=</span>maxPool<span class="token punctuation">(</span>aF<span class="token punctuation">(</span>cov1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>adaptivePool<span class="token punctuation">(</span>aF<span class="token punctuation">(</span>cov2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#这个是压缩为二维向量</span>    x<span class="token operator">=</span>aF<span class="token punctuation">(</span>linear1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>sigmoid<span class="token punctuation">(</span>linear2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#主要是考虑到这是个概率，所以用个sigmoid变换到0~1</span>    <span class="token keyword">return</span> x</code></pre><h2 id="前向和反向">前向和反向</h2><p>首先先将输入的东西变成tensor，丢进去forward输出用个概率，和标准比对，开始是反向更新。首先先重置优化器的梯度，optimizer用的是optim.SGD(net.parameters(),lr)，其中net.parameters()是需要更新的参数，lr是learningRate（具体参数自己找pytorch，笑死，毫无指引）。loss采用交叉熵<code>nn.CrossEntropyLoss</code>，参数为两个float，我是把两个tensor给.float再导进去。然后对loss进行一个.backward()来取梯度，再optimizer.step()来进行一个步进更新。我最后面返回了一个loss.item()，问题是这个是啥我还没看懂，说是loss但是很不平滑。</p><h2 id="将音频流切片丢进去判断有没有激活">将音频流切片丢进去判断有没有激活</h2><p>就是验证部分，取了数据集里面的另一部分来进行检验，我做出来是0.93的准确率。</p><h2 id="从外部输入音频流">从外部输入音频流</h2><p>使用pyaudio库。首先是用<code>audio=pyaudio.PyAudio()</code>初始化一个类变量，调用函数<code>stream=audio.open(参数)</code>进行初始化设置，调用<code>data=stream.read(参数)</code>来获取音频流，音频流是记为两位十六进制数的二进制字符串，我是用<code>np.frombuffer(stream.read(这里是frames_per_buffer),dtype=np.float32)</code>来变换的，记得因为是实时音频流所以写while里面，至于这堆二进制怎么变成波形图就靠np罢（称赞一下写综述的大大，该方法经过一系列采坑后通过<a href="zhuanlan.zhihu.com/p/611234973">综述</a>找到的。<br>采集设备也比较重要，好的麦克风可以先处理掉一部分噪声，收音也更集中。一开始用耳麦做的时候噪点非常多，回来换了舍友的麦之后梅尔图干净了不少。但是还是有个问题，我是按处理.wav输入的方式处理<code>np.frombuffer</code>解析的数据，既把它的返回直接当成时域的信号，清洗后输入转换成梅尔图，再与先前获取的底噪的梅尔图相减。结果上看，结果归一化后，较大值比较多，较小值比较少，与从.wav中获取的梅尔图恰相反。</p><h2 id="遇到的问题（只能想起一些li）">遇到的问题（只能想起一些li）</h2><p>比如说最开始的梅尔图，会导致输入的图大部分数在0~1少部分在10以上或者-10以下，归一化之后就会导致大部分数挤在中间（当然，你不归一化就没有这个烦恼了 大概 我懒得优化了 <s>反正也是堆屎山</s>），所有没用原本的log2函数，而且有负数，所以考虑了用有负数部分的泄露relu函数变形。<br>然后还有就是如果发现自己训练的RC比例和样本比例相同那可能就是你样本有问题（别问我怎么知道的），我训练目标用的是<a href="http://www.openslr.org/85/">北京希尔贝壳的HIMIA数据集</a>（吐槽一下，我发现为什么英文只有女声，是我查找的问题吗？），训练的非目标样本是随便截的音频。<br>我使用<code>nn.AdaptiveMaxPool2d</code>是考虑了输入的音频长度可能有一定范围的差别，所以加的，你当然可以不加，你喜欢的话awa一开始做那个外部音频流的时候就只找到pyaudio能采集，然后一开始用np.fromstring来处理二进制发现经过很奇怪，没法转换到tensor中进行MelSpectrogram，所以又试了wave库，本来要试ffmpeg的，结果发现Python上的ffmpeg库是只能处理视频的半成品，然后就放弃了去查综述。MelSpectrogram的语法是<code>MelSpectrogram(参数)(tensor形式的输入)</code>，如果报了int is not callable之类的（具体忘了x）那应该是MelSpectrogram的输入你搞错了，请检查一下输入是否为tensor，以及维度（？这个不确定会不会是）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 代发 </tag>
            
            <tag> 开发笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再游湖畔</title>
      <link href="/2023/03/35335.html"/>
      <url>/2023/03/35335.html</url>
      
        <content type="html"><![CDATA[<p>子在川上曰：“逝者如斯夫，不舍昼夜”。时间如河水一般滚滚流去，曾经熟悉的事物所发生的变化也大得让人吃惊。</p><p>时隔两个月，我又一次循着熟悉的湖边小路散步。拦腰高的石头围栏，被齐胸高、涂着黑灰色油漆的铁制栏杆所取代。和两个月前相比，本就很低的水位变得更低了。原本靠近湖岸的浅滩被剥去外衣，露出崎岖不平的身躯。长在湖的一角的一片矮竹林被连根拔起装进垃圾袋，随意地放在路旁。这片林子曾经充满了鸟儿们的欢声笑语。</p><p><img src="https://cdn.ncmc.me/2023/03/00/00.jpg" alt="路旁的遗弃物"></p><p>在另一个角落，我发现了那些被替换掉、兢兢业业几十载的石围栏的最终归宿——它们躺在水里一言不发，不知是嘲讽，抑或是悲哀。</p><p><img src="https://cdn.ncmc.me/2023/03/00/01.jpg" alt="水中石柱"></p><p>距离上一次在湖畔散步不过数周，在某位领导的脑子一热、大腿一拍之下，这片湖就发生了如此大的变化。实在不得不感慨世事难料。静止的事物尚且如此，人就更过之而无不及了。也不知下次再见到那位临走时说”我没有家“的特殊的女孩子的时候，她是否也会发生如此大的变化呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王爽《汇编语言》实验5 (5)</title>
      <link href="/2023/02/17545.html"/>
      <url>/2023/02/17545.html</url>
      
        <content type="html"><![CDATA[<h2 id="原题">原题</h2><p>编写code段中的代码，将a段和b段数据依次相加，结果存入c段</p><pre class="language-none"><code class="language-none">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c endscode segmentstart:？？？？？？？    mov ax,4c00h    int 21hcode endsend start</code></pre><h2 id="思路">思路</h2><p>这个题有三个数据段，但是段寄存器只有ds,es两个。。。手上这本旧课本的主人写的笔记是拿ss当第三个段寄存器，这。。。应该不行吧？想破头也想不通，遂谷歌之。</p><p>其中一种解决思路是引入更多的寄存器。比如si,di等。因为之前没有接触过这类寄存器，不知道使用上有什么讲究，因此不采用这种思路。</p><p>还有一种思路是利用栈暂存段寄存器中的数据，暂时更改段寄存器指向的段，后面再恢复成原来的值。</p><p>核心代码:</p><pre class="language-none"><code class="language-none">push dsmov ax,cmov ds,ax......pop ds</code></pre><p>这种思路虽然效率不太好，但是知识范围没有超纲。</p><p>最终代码如下</p><pre class="language-none"><code class="language-none">  mov ax,a  mov ds,ax  mov ax,b  mov es,ax  mov ax,0  mov bx,0  s:mov al,[bx]  add al,es:[bx]  push ds  mov dx,c  mov ds,dx  mov [bx],ax  pop ds  inc bx  loop s    mov ax,4c00h  int 21h</code></pre><h2 id="补充">补充</h2><p>调试过程中，曾经利用ax来作为偏移量寻址，类似 mov bl,[ax] 这样的，但是编译时报错，查阅资料发现16位处理器不能使用ax寻址，原因不知道。（书上貌似没写）（补充：在后面第8章写了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开端</title>
      <link href="/2023/02/21985.html"/>
      <url>/2023/02/21985.html</url>
      
        <content type="html"><![CDATA[<p>开学了。</p><p>恰是春季，尽管还有些许寒意，也难掩生机勃勃。曾经因封控而变得冷清的街道，也恢复了往日的繁荣。</p><p>火车站一如既往，不一样的是车站大门口悬挂的写着“请出示健康码”的牌子不见了，那些低头操作手机寻找健康码、堵住通道的旅客没有了。候车大厅也似乎比过去更热闹了。</p><p><img src="https://cdn.ncmc.me/2023/02/02/00.jpg" alt="火车站"></p><p>不知是常态还是今天乘客带的行李特别多，上了高铁，就看见乘务员们为了乘客们的行李前后忙活。时而大声询问不按规定放置、堵塞通道的行李属于哪位乘客，时而挪开堵住车内洗手间门的行李箱。好不容易才在车开之前，把所有的大件行李都放到合适的位置。</p><p>进了校门，一度设置在门后，检查返校生健康证明和健康申报结果的关卡早已不见踪影。站在一个又一个遮雨棚接起来形成的长长的通道入口，可以毫无阻拦地看见另一端的出口。</p><p>总感觉乌云散去后露出的天空特别蓝，天朗气清，微风拂面。</p><p>真惬意啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群星异闻录</title>
      <link href="/2023/02/48452.html"/>
      <url>/2023/02/48452.html</url>
      
        <content type="html"><![CDATA[<h1><span style="display:block;text-align:center;color:lightblue;">群星异闻录</span></h1><p>本文非原创，是代替某卷王存档的文章</p><h2 id="前言">前言</h2><p>本书用于记录作为第四天灾时，游走在星际之间的见闻与事件，事件不一定都是原版的，遇到的事件也是随机的，因此不一定能记录完整。部分文案为手打，可能存在错漏，部分事件名为主观命名。</p><h2 id="阿斯特莱雅遗迹">阿斯特莱雅遗迹</h2><p>本事件应该属于伞mod，挖掘遗迹所触发的事件，事件结束后获得一名科学家和一个遗珍。<font color="darkorchid">遗珍</font>为伞の奇怪脑袋（问号凯露头）；替换挖掘遗迹的科学家为多多良小鼬，多多良小鼬额外有用<font color="#41C3E5">伞鼬</font>和<font color="#41C3E5">奇怪的异色瞳</font>两个属性，<font color="#41C3E5">伞鼬</font>给予航速提升和不朽，<font color="#41C3E5">奇怪的异色瞳</font>给予调查速度和考古速度提升。</p><h2 id="大的药">大的药</h2><p>准确来说，这是一个物品，一个<font color="darkorchid">遗珍</font>，应该属于伞mod。一颗红黄的药丸，无被动效果，激活效果标注为“不要使用这个东西”，用红色的字标注“这是个陷阱”，底下用彩色的字写有“点下去”。启动消耗100影响力，启用后游戏崩溃闪退。</p><h2 id="缇扬奇乱坟岗">缇扬奇乱坟岗</h2><p>在地图中有一群缇扬奇会守着一个星球，为遗迹。该掘遗迹有4个阶段和一个前置。前置要求杀死守墓的缇扬奇，缇扬奇群战力约200+，或者用工程船搭建一个缇扬奇诱饵吸引守墓的缇扬奇。<br>第一阶段，肉之球</p><blockquote><p>我们实在是很难说奥列克-伍尔到底算不算作一个行星: 初步钻探发现的是一层又一层的生物组织。据估计，总共需要2,435,463只提扬奇尸体才能产生此等规模的行星(质量误差范围5.3%)。即使我们假设地核是一块岩石，尸体只是堆叠在上面，涉及到的样本数量依然是无比庞大的。是某人或者某种事物将绕扬奇带到这里让它们死去，还是说它们只是顺其白然地来到这里度过品后的时光。然后死去?</p></blockquote><p>第二阶段，死亡三步</p><blockquote><p>遍布奥列克-伍尔地表的死亡堤扬奇的那种不寻常·…·的活动，似乎是它们再生能力的一种副作用: 即使技术上已经判定为死亡，它们的尸体仍旧在不断地重组再生。这个恒星系拥有着非比寻常般丰富的营养物质，尤其是堤扬奇游荡的那个气态巨行星。或许这解释了为什么我们之前从未观察到这样的行为。然而，这个发现并没有解释为什么这些死去的生物像是在被某种单一思维控制一样蠕动，不断地伸出触手，吞食新近降落到这个行星上的尸体。</p></blockquote><p>第三阶段，尸山血海迷宫</p><blockquote><p>我们的挖掘队发掘到了一个复杂的隧道网络，从奥列克-伍尔的地表一直延伸到地下深处。化学分析确认迷宫的墙体是由压实的绕扬奇组织构成，尽管其年代甚至超过了我们的帝国，但肉质还散发着温热，甚至几乎没有腐败。看上去就像是这些尸体自己聚合到了一起，重构其形态建立了这个地方·…·但是为什么?</p></blockquote><p>第四阶段，隧道魅影</p><blockquote><p>在对奥列克-伍尔的地下隧道网络进行测绘的时候，我们的科学家突然意识到，这个隧道网络同一只提扬奇的血管系统极其相似一一但是其规模跟我们之前遇到的那只在星辰间游荡的缇扬奇族母差不多。那些搏动的墙壁散发着轻微的温暖，随着探险队逐渐接近行星的核心，墙壁的温度也在慢慢提升一一在核心处，我们的扫描仪捕捉到了一个微弱的生命信号。</p></blockquote><p>第四阶段，主脑</p><blockquote><p>在一个庞大的地下穴室中，一只缇扬奇竖立地站着，钟型的脑袋微微地摇晃着，它细线一样的触手舒展开来，连接着穴室的外墙。看上去它成为了某种控制单元，不断操纵、指引着这个行星级别墓地的生长。我们的科学家没法断定这个过程什么时候会完成，但是相信一旦这只生物苏醒，它会成为远比普通的缇扬奇要大得多，也恐怖得多的存在：这只生物值得我们视作一只新的缇扬奇族母。</p></blockquote><p>触发两个选项，一个是在不干扰的情况下观察和研究，获得大量<font color="#71C96D">社会学研究点数</font>，另一个是将其作为样本卖给策展人，获得<font color="#E5C100">5k能量币</font>。</p><h2 id="令人熟悉的挖掘">令人熟悉的挖掘</h2><p>遗迹。令人不寒而栗</p><h2 id="小行星防爆门">小行星防爆门</h2><p>遗迹，倒还挺常见的，每把都有。<br>第一阶段，钻出一个洞</p><blockquote><p>某种非常巨大的建筑物占据了J3L1-J88小行星的绝大部分内部空间。作为这个建筑物唯一入口的防爆门至今仍无法被打开，但是一条从小行星另一侧的通道已经被挖掘出来。我们的钻头目前仍无法钻透这个建筑物厚实的外壁，但这个方法似乎仍然提供了进入的最佳机会。尽管它们已经过千年风沙，但是防爆门仍然被证实是坚不可摧的。</p></blockquote><p>第二阶段，入口</p><blockquote><p>我们最终还是在J3L1-J88内建筑物的外墙上钻出了一个洞。它的内部是一个宽广的指挥中心，或者是某种地堡，其中零散的散布着几千个腐朽的外星人遗骸。仔细研究这些，将会让我们得到一张关于当年这颗小行星内部所发生事件更为清晰的图片，这也将花费相当长的时间。</p></blockquote><p>第三阶段，指挥中心</p><blockquote><p>这颗小行星曾经作为一个相对较大的星际帝国的隐匿首都，该帝国在数千年前曾经统治着这片星区。有了这样堡垒化的指挥中心，帝国的统治精英们可以与数以千计的军事或民政官员一道安全无虞地发号施令，不受其苛政引起的暴乱所威胁。小行星与帝国的其余部分的联系只依靠加密的亚空间通讯和一艘定期来访以补给基地物资和运送人员的货船来进行。</p></blockquote><p>第四阶段，最后时日</p><blockquote><p>从拼凑的数据来看，这艘补给货船似乎是由于推进器故障而与小行星相撞的。<br>碰撞产生的爆炸破坏力防爆门，并摧毁了小行星的亚空间发射器，永久地切断了它与外界的所有联系。<br>陷入了困境，更没有得救的希望，小行星的居民慢慢地死于饥饿或自杀。他们唯一残存的子空间接收器的最后日志证实，他们的帝国突然失去了首都，随后陷入内战和混乱中。</p></blockquote><h2 id="缇扬奇族母">缇扬奇族母</h2><p>敌对BOSS，击杀后触发事件“解剖缇扬奇族母”并放出困于缇扬奇族母体内的一艘战列舰“亚哈船长号”，该舰初始不满血，完整综合效能为279，主要使用鱼雷（因为是炮击作战电脑）。完成“解剖缇扬奇族母”后，首都获得buff”祖姆鞭毛“，在首都每月有机人口<font color="#83D883">+1</font>，并<font color="red">-5</font>稳定度，事件可以概括为巡游途中鞭毛对周围的人产生了克隆。</p><h2 id="跟随科研舰的太空变形虫母">跟随科研舰的太空变形虫母</h2><p>拥有“安抚变形虫”的buff时可能产生，可以选择甩掉或者养着，一开始会跟随科研船，可以作为战舰参与战斗，长大后有19的综合效能。可以在给定的名字表中选取名字，因此一般称为“泡泡”，翻名字表到最后可以命名为“毛球”。</p><p class="hideblack">（但是不会有人把它派上前线吧 都是当宠物养的）</p><p></p><h2 id="化石遗骸">化石遗骸</h2><p>遗迹。初始描述</p><blockquote><p>在███████上的一个大而与世隔绝的山谷中一些不同物种的化石被发现了，这些物种似乎不是来自该行星的。它们大体上都来自同一个时期，大约是360万年前，跨度为几个世纪的那段时间内。这些物种中的每一个个体似乎都是在其所属的独特的生物圈中进化而来的而且它们似乎都具有智慧。奇怪的是，到目前为止发现的每一个化石都显示出遭到暴力终结的迹象。</p></blockquote><p>第一阶段，更多遗骸</p><blockquote><p>考古学家们在山谷中发掘出了越来越多的化石残骸，到目前为止已经有26种不同的智慧物种了，它们都不是███████的本士物种。那些保存程度较高，能用于确定死亡原因的化石都表明这些物种死于刀刃予或箭造成的物理创伤。似乎没有任何样本是被现代炮弹或能量武器等类似的装备所击倒的。在山谷入口附近发现了某种小型结构的废墟。它似乎与这些化石来源于同一时期。也许这会使事情变得明朗一些。</p></blockquote><p>第二阶段，小屋</p><blockquote><p>对峡谷入口周边发现的古代建筑结构的发掘工作正按照计划稳步进行中。许多文物被发现，大多数文物似乎是各种狩猎武器和战利品。一个被部分翻译的标志似乎是该结构的名字，意为:</p><center>马克维尔之谷一第一狩猎屋</center><p></p></blockquote><p>第三阶段，雷塔拉克斯领域</p><blockquote><p>对狩猎屋周边的持续发掘提供了更多的细节信息。███████和马克维尔之谷是作为一个被称为雷塔拉克斯领域的星际政体的武士同志阶级的狩猎保留地。雷塔拉克斯是掠夺性的禽类物种，周期性地纳集他们统治下的外星附庸文明的随机个体。这些外星物种按照统治雷塔拉克斯社会的仪式在马克维尔的荒野被狩猎并杀害。</p></blockquote><h2 id="外星生物标本收集">外星生物标本收集</h2><p>科研任务，要在领土内调查7种生物。任务描述为</p><blockquote><p>███████的外太空生物博物馆发来请求，他们想请求帮助收集在各个星球上鉴别出的一些稀有外星生命体。</p></blockquote><p>幻影般的塔布拉克强大的塔萨古德</p><blockquote><p>塔萨古德是一种十分致命的捕食者。<br>每当夜晚降临，他们便蛰伏在███████的密林之中，用电击来麻痹他们的猎物，接着便用吸管一样的嘴吸食猎物的大脑。<br>不幸的是，三个█████船员连一个塔萨古德的样本都没有捕获到就被它们给消灭了。<br>为了表彰这些勇敢的船员，███████的外星生物博物馆会用他们的名字来重新命名建筑的一翼。</p></blockquote><p>卑鄙的欧林提</p><blockquote><p>欧林提是一种█████████当地的小型啮齿类生物，他们的居住站已经蔓延到行星大部分的地区。<br>他们以惊人的速率繁殖后代，而且它们似乎有啃食电缆的癖好。<br>收集欧林提的样本并不麻烦。<br>事实上，在完成首批收集之后，更多的欧林提通过搭乘科学飞船的轨道穿梭机偷渡到了███████。<br>至于为何宇宙生物博物馆会要欧林提这种样本，其原因还是个谜。</p></blockquote><p class="hideblack">对啊 为什么啊</p><p>阴险的萨尼兰坚韧的古兰萨</p><blockquote><p>古兰萨是一种巨大、扁平的食草动物，它们体内有气囊，这使得它们能悬浮在离地表几厘米的地方。<br>它们总是成群结队地行动，在█████████多风的平原上吃苔藓和地衣。古兰萨正在被卫星的顶端捕食者无情地猎杀。<br>我们█████上的生物学家预计，只有大约百来群的古兰萨还活着。<br>这当中的一群——由九头古兰萨组成，已经被成功地收集并带回了███████。</p></blockquote><p>狡猾的乌杜兰</p><blockquote><p>███████的船员成功地在█████████的冰层上收集到了一小群的乌杜兰。这些毛茸茸的白色杂食动物把自己滚成一个球，以惊人的速度滚过行星的雪原一一经测量，其中一只的速度竟达到了80公里每小时。我们之所以能侦测到它们是因为它们所到之处都会扬起阵阵飞雪。</p></blockquote><p>贪婪的祖卡</p><blockquote><p>祖卡是群居的虫类生物，它们体型巨大，且以地里的岩石和矿物等无机物为食，这两个特点都足够让人瞠目结舌。<br>一艘█████████的穿梭机遭受重大损失。当时该穿梭机只是不经意间经过了一群祖卡身边，却招致祖卡聚集而来蚕食舰体。在█████的外星生物博物馆已经开始建造关住这种生物的特制容器。</p></blockquote><h2 id="埃迪克巨石">埃迪克巨石</h2><blockquote><p>朱鲁VII无人居住，也确实无法居住，但却并非无人造访过。<br>它的表面散布着许多高耸的尖碑，由某种非本星的矿物雕刻，显然是由某种热衷艺术的太空文明所置放于此。<br>这些碑塔流动的曲线雕琢出了一段如此如梦似幻的历史，其一定是虚拟的。<br>一定是。</p></blockquote><p>只有一个选项“拍摄后存入档案”，无意间触发的，也有注意触发条件，但是他最后那个“一定是”就很意味深长。</p><h1>说客</h1><blockquote><p>星海共同体中夹杂着一阵不和谐的杂音，不是所有人都很友好，肯定地说这其中必有与█████的利益不一致的人。<br>不妙的是，大使██████████似乎正在听取某种错误的声音。<br>在参加由全能██学团体主办的几场会议中，他们的眉毛止不住地上翘。<br>现在一切都水落石出了，一笔可以追溯到某个组织的巨款被查明汇入了他们的账户。<br>█████的同事们要求将他们召回并发起不信任议案。<br>然而，某些更为狡诈的顾问建议我们和他们达成一笔交易，维持其现有职位以换取获得情报的机会。</p></blockquote><p>我是选择把他们召回，相当于冻结这个外交官1080天。如果不召回的话，会按百分比减在星海共同体的权重，减不起。不过有一说一，这个事件发生我才注意到，怎么极端理性里面会有神学团体？</p><h2 id="紫雨">紫雨</h2><blockquote><p>由███████的地表探测器拍摄的朱鲁IIIa上迷人紫雨的图像，辗转流传到██████的文化精英手中。<br>虽然这个发现毫无科研价值，但令人浮想联翩的斑斓降雨图像在██的艺术领域依然擦出了一点复兴的火花，这一事件也许多年之后才会开花结果。</p></blockquote><p>该事件会给予20年的幸福度<font color="#83D883">+10%</font>buff——受启发的艺术。虽然但是，p社又懒得画紫雨，拿孢子事件的图糊弄我，而且该事件到目前为止还没有后续。</p><h1>圣夜绝域事件链</h1><h1>远古机器人星球</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 代发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置防盗链</title>
      <link href="/2023/02/53518.html"/>
      <url>/2023/02/53518.html</url>
      
        <content type="html"><![CDATA[<p>由于打算把图片放在自己的服务器上，所以配置防盗链也成了一个必须完成的任务。</p><p>在网上搜了一下，大致上是利用nginx检测http请求头中的referer参数来判断是否返回图片。</p><pre class="language-none"><code class="language-none">location / {    root html/img;    valid_referers none blocked  *.example.com example.com ;    if ($invalid_referer) {        return 403;        break;     }     access_log off;}</code></pre><p>重点在第3行"vaild_referers"的设置。</p><p>根据<a href="http://nginx.org/en/docs/http/ngx_http_referer_module.html#valid_referers">nginx官方文档</a>的解释，"valid_referers"的几个参数实际上是几个条件。</p><p>"none"参数表示http header中没有referer,"blocked"表示http header中有referer但被防火墙或者代理服务器删除，后面指定的域名表示在referer中匹配到相应的域名。只要满足以上任意一条，$invalid_referer变量则变为<strong>空字符串</strong>， 否则为1。可以通过判断该变量的值来确定请求是否合法，达到防盗链的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用three.js创建3D场景</title>
      <link href="/2023/02/36984.html"/>
      <url>/2023/02/36984.html</url>
      
        <content type="html"><![CDATA[<h2 id="总流程">总流程</h2><ul><li>新建一个空的场景</li><li>添加相机和灯光</li><li>添加各个物体</li><li>创建渲染器</li><li>使用渲染器渲染场景</li></ul><h2 id="新建场景">新建场景</h2><p>直接新建一个场景对象</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">import * as THREE from "three"; //导入const scene = new THREE.Scene();scene.background = new THREE.color(0x0); //背景为黑色，默认值</code></pre><h2 id="添加相机">添加相机</h2><p>多数情况下使用的相机是透视相机，这种相机模拟人眼的观察，示意图如下，紫色棱台包括的范围内，物体会被渲染(图片来自 <a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene">Rachel Smith</a>)<img src="https://cdn.ncmc.me/2023/02/00/00.jpg" alt="透视相机"></p><p>这种相机有个问题：物体在靠近场景边缘的时候会变形。因此我后来采用正交相机。正交相机和透视相机类似，但渲染的空间是个四棱柱。没有图片，自行脑补（懒。</p><p>正交相机使用时要注意渲染范围的长宽比要和场景的长宽比一致，否则物体会变形。（下面的代码中，假设场景的长宽比和窗口的长宽比一致）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//透视型照相机</span><span class="token keyword">const</span> camera <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">THREE<span class="token punctuation">.</span>PerspectiveCamera</span><span class="token punctuation">(</span>    <span class="token number">100</span><span class="token punctuation">,</span> <span class="token comment">//视野角度fov</span>    window<span class="token punctuation">.</span>innerWidth <span class="token operator">/</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">,</span><span class="token comment">//长宽比</span>    <span class="token number">0.1</span><span class="token punctuation">,</span><span class="token comment">//最近渲染距离(就是near plane到照相机的距离)</span>    <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最远渲染距离(类似，far plane)</span>camera<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span></code></pre><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//正交照相机let renderWidth = 60;let windowWidth = window.innerWidth,windowHeight = window.innerHeight;const camera = new THREE.OrthographicCamera(  -renderWidth,//渲染左边界  renderWidth,//渲染右边界  renderWidth*windowHeight/windowWidth,//渲染上边界  -renderWidth*windowHeight/windowWidth,//渲染下边界  5,//最近渲染距离  100);//最远渲染距离camera.position.z = 20;</code></pre><h2 id="添加灯光">添加灯光</h2><p>这玩意还没搞懂，先用着最简单的</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const light = new THREE.AmbientLight(0x404040);scene.add(light);</code></pre><h2 id="添加物体">添加物体</h2><p>添加物体四步走：指定物体类型，指定物体材质，创建物体对象，添加物体到场景。以一个棱长为5的正四棱柱为例：</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let geometry = new THREE.BoxGeometry(5, 5, 5);//长宽高let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });let box0 =  new THREE.Mesh(geometry, material);scene.add(box0);</code></pre><p>一般情况下，创建完geometry、material两个变量不会再被使用，所以创建部分也可以写成一句</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let box0 =  new THREE.Mesh(    new THREE.BoxGeometry(5, 5, 5),     new THREE.MeshBasicMaterial({ color: 0xff0000 }));</code></pre><h2 id="创建渲染器并渲染场景">创建渲染器并渲染场景</h2><p>这东西也没研究，照抄官方教程。</p><p>需要提前在网页中创建id为"container"的标签来容纳场景。</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);//渲染的大小就是场景的大小document.getElementById("#container").append(renderer.domElement);renderer.render(scene);</code></pre><p>这几步都完成以后打开网页，就能看见场景和刚才创建的红色四棱柱了。</p><h2 id="参考">参考</h2><p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">Three.js documentation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发笔记 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript压缩和混淆</title>
      <link href="/2023/02/55798.html"/>
      <url>/2023/02/55798.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JavaScript压缩和混淆？">什么是JavaScript压缩和混淆？</h2><p>开发人员编写JS代码的时候，有许多格式规范，写出来的代码十分易读、方便开发。而各大网站使用的JS代码，多数都是挤成一团的，肉眼看上去毫无章法可言，可读性几乎为零。</p><p>这些让人“不忍直视”的代码，就是被压缩和混淆过的。一般的压缩通常只是除去注释、空行和空格等，而混淆还会将变量名、函数名等替换成一些无意义的字符，还可能会添加一些无意义的代码。</p><h2 id="如何进行压缩和混淆？">如何进行压缩和混淆？</h2><p>目前比较流行的混淆工具有Uglify和Google Closure Compiler等。在混淆的过程中，工具还会对代码进行优化，有点类似于C语言编译器的预处理。</p><h2 id="压缩、混淆的作用">压缩、混淆的作用</h2><p>主要是提高JavaScript代码的运行效率，缩小代码体积。一定程度上还可以隐藏代码的运行逻辑起到版权保护的作用。</p><h2 id="随便写写">随便写写</h2><p>个人认为压缩、混淆对代码的保护作用十分有限。如果使用的是一般的混淆方法，很容易就能够还原出大致的框架。部分混淆方法混淆的代码甚至可以完整还原出所有变量名。尽管有些比较“变态”的加密工具，如JavaScript Obfuscator，可以真正做到加密代码，但这最多也就是提高逆向成本罢了。如果真的既要保护代码又非得用JS不可，感觉WebAssembly是个比较好的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
