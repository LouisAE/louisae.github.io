<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>再游湖畔</title>
      <link href="/2023/03/7.html"/>
      <url>/2023/03/7.html</url>
      
        <content type="html"><![CDATA[<p>子在川上曰：“逝者如斯夫，不舍昼夜”。时间如河水一般滚滚流去，曾经熟悉的事物所发生的变化也大得让人吃惊。</p><p>时隔两个月，我又一次循着熟悉的湖边小路散步。拦腰高的石头围栏，被齐胸高、涂着黑灰色油漆的铁制栏杆所取代。<br>和两个月前相比，本就很低的水位变得更低了。原本靠近湖岸的浅滩被剥去外衣，露出崎岖不平的身躯。<br>长在湖的一角的一片矮竹林被连根拔起装进垃圾袋，随意地放在路旁。这片林子曾经充满了鸟儿们的欢声笑语。</p><p><img src="https://cdn.ncmc.me/2023/02/03/00.jpg" alt="路旁的遗弃物"></p><p>在另一个角落，我发现了那些被替换掉、兢兢业业几十载的石围栏的最终归宿——它们躺在水里一言不发，不知是嘲讽，抑或是悲哀。</p><p><img src="https://cdn.ncmc.me/2023/02/03/01.jpg" alt="水中石柱"></p><p>距离上一次在湖畔散步不过数周，在某位领导的脑子一热、大腿一拍之下，这片湖就发生了如此大的变化。实在不得不感慨世事难料。静止的事物尚且如此，人就更过之而无不及了。也不知下次再见到那位临走时说”我没有家“的特殊的女孩子的时候，她是否也会发生如此大的变化呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王爽《汇编语言》实验5 (5)</title>
      <link href="/2023/02/6.html"/>
      <url>/2023/02/6.html</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>编写code段中的代码，将a段和b段数据依次相加，结果存入c段</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c endscode segmentstart:？？？？？？？    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题有三个数据段，但是段寄存器只有ds,es两个。。。手上这本旧课本的主人写的笔记是拿ss当第三个<br>段寄存器，这。。。应该不行吧？想破头也想不通，遂谷歌之。</p><p>其中一种解决思路是引入更多的寄存器。比如si,di等。因为之前没有接触过这类寄存器，<br>不知道使用上有什么讲究，因此不采用这种思路。</p><p>还有一种思路是利用栈暂存段寄存器中的数据，暂时更改段寄存器指向的段，后面再恢复成原来的值。</p><p>核心代码:</p><pre class="line-numbers language-none"><code class="language-none">push dsmov ax,cmov ds,ax......pop ds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种思路虽然效率不太好，但是知识范围没有超纲。</p><p>最终代码如下</p><pre class="line-numbers language-none"><code class="language-none">  mov ax,a  mov ds,ax  mov ax,b  mov es,ax  mov ax,0  mov bx,0  s:mov al,[bx]  add al,es:[bx]  push ds  mov dx,c  mov ds,dx  mov [bx],ax  pop ds  inc bx  loop s    mov ax,4c00h  int 21h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>调试过程中，曾经利用ax来作为偏移量寻址，类似 mov bl,[ax] 这样的，但是编译时报错，<br>查阅资料发现16位处理器不能使用ax寻址，原因不知道。（书上貌似没写）（补充：在后面第8章写了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开端</title>
      <link href="/2023/02/4.html"/>
      <url>/2023/02/4.html</url>
      
        <content type="html"><![CDATA[<p>开学了。</p><p>恰是春季，尽管还有些许寒意，也难掩生机勃勃。曾经因封控而变得冷清的街道，也恢复了往日的繁荣。</p><p>火车站一如既往，不一样的是车站大门口悬挂的写着“请出示健康码”的牌子不见了，那些低头操作手机寻找健康码、堵住通道的旅客没有了。<br>候车大厅也似乎比过去更热闹了。</p><p><img src="https://cdn.ncmc.me/2023/02/02/00.jpg" alt="火车站"></p><p>不知是常态还是今天乘客带的行李特别多，上了高铁，就看见乘务员们为了乘客们的行李前后忙活。时而大声询问不按规定放置、堵塞通道的行李属于哪位乘客，<br>时而挪开堵住车内洗手间门的行李箱。好不容易才在车开之前，把所有的大件行李都放到合适的位置。</p><p>进了校门，一度设置在门后，检查返校生健康证明和健康申报结果的关卡早已不见踪影。<br>站在一个又一个遮雨棚接起来形成的长长的通道入口，可以毫无阻拦地看见另一端的出口。</p><p>总感觉乌云散去后露出的天空特别蓝，天朗气清，微风拂面。</p><p>真惬意啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群星异闻录</title>
      <link href="/2023/02/5.html"/>
      <url>/2023/02/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="群星异闻录"><a href="#群星异闻录" class="headerlink" title="群星异闻录"></a><span style="display:block;text-align:center;color:lightblue;">群星异闻录</span></h1><p>本文非原创，是代替朋友存档的文章</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本书用于记录作为第四天灾时，游走在星际之间的见闻与事件，事件不一定都是原版的，遇到的事件也是随机的，因此不一定能记录完整。部分文案为手打，可能存在错漏，部分事件名为主观命名。</p><h2 id="阿斯特莱雅遗迹"><a href="#阿斯特莱雅遗迹" class="headerlink" title="阿斯特莱雅遗迹"></a>阿斯特莱雅遗迹</h2><p>本事件应该属于伞mod，挖掘遗迹所触发的事件，事件结束后获得一名科学家和一个遗珍。<font color="darkorchid">遗珍</font>为伞の奇怪脑袋（问号凯露头）；替换挖掘遗迹的科学家为多多良小鼬，多多良小鼬额外有用<font color="#49d9ff">伞鼬</font>和<font color="#49d9ff">奇怪的异色瞳</font>两个属性，<font color="#49d9ff">伞鼬</font>给予航速提升和不朽，<font color="#49d9ff">奇怪的异色瞳</font>给予调查速度和考古速度提升。</p><h2 id="大的药"><a href="#大的药" class="headerlink" title="大的药"></a>大的药</h2><p>准确来说，这是一个物品，一个<font color="darkorchid">遗珍</font>，应该属于伞mod。一颗红黄的药丸，无被动效果，激活效果标注为“不要使用这个东西”，用红色的字标注“这是个陷阱”，底下用彩色的字写有“点下去”。启动消耗100影响力，启用后游戏崩溃闪退。</p><h2 id="缇扬奇乱坟岗"><a href="#缇扬奇乱坟岗" class="headerlink" title="缇扬奇乱坟岗"></a>缇扬奇乱坟岗</h2><p>在地图中有一群缇扬奇会守着一个星球，为遗迹。该掘遗迹有4个阶段和一个前置。前置要求杀死守墓的缇扬奇，缇扬奇群战力约200+，或者用工程船搭建一个缇扬奇诱饵吸引守墓的缇扬奇。<br>第一阶段，肉之球</p><blockquote><p>我们实在是很难说奥列克-伍尔到底算不算作一个行星: 初步钻探发现的是一层又一层的生物组织。据估计，总共需要2,435,463只提扬奇尸体才能产生此等规模的行星质量误差范围5.3%)。即使我们假设地核是一块岩石，尸体只是堆叠在上面，涉及到的样本数量依然是无比庞大的。是某人或者某种事物将绕扬奇带到这里让它们死去，还是说它们只是顺其白然地来到这里度过品后的时光。然后死去?  </p></blockquote><p>第二阶段，死亡三步</p><blockquote><p>遍布奥列克-伍尔地表的死亡堤扬奇的那种不寻常·….·的活动，似乎是它们再生能力的一种副作用: 即使技术上已经判定为死亡，它们的尸体仍旧在不断地重组再生。这个恒星系拥有着非比寻常般丰富的营养物质，尤其是堤扬奇游荡的那个气态巨行星。或许这解释了为什么我们之前从未观察到这样的行为。然而，这个发现并没有解释为什么这些死去的生物像是在被某种单一思维控制一样蠕动，不断地伸出触手，吞食新近降落到这个行星上的尸体。  </p></blockquote><p>第三阶段，尸山血海迷宫</p><blockquote><p>我们的挖掘队发掘到了一个复杂的隧道网络，从奥列克-伍尔的地表一直延<br>伸到地下深处。化学分析确认迷宫的墙体是由压实的绕扬奇组织构成，尽管其年代甚至超过了我们的帝国，但肉质还散发着温热，甚至几乎没有腐败。看上去就像是这些尸体自己聚合到了一起，重构其形态建立了这个地方·…·但是为什么?  </p></blockquote><p>第四阶段，隧道魅影</p><blockquote><p>在对奥列克-伍尔的地下隧道网络进行测绘的时候，我们的科学家突然意识到，这个隧道网络同一只提扬奇的血管系统极其相似一一但是其规模跟我们之前遇到的那只在星辰间游荡的缇扬奇族母差不多。那些搏动的墙壁散发着轻微的温暖，随着探险队逐渐接近行星的核心，墙壁的温度也在慢慢提升一一在核心处，我们的扫描仪捕捉到了一个微弱的生命信号。</p></blockquote><p>第四阶段，主脑</p><blockquote><p>在一个庞大的地下穴室中，一只缇扬奇竖立地站着，钟型的脑袋微微地摇晃着，它细线一样的触手舒展开来，连接着穴室的外墙。看上去它成为了某种控制单元，不断操纵、指引着这个行星级别墓地的生长。我们的科学家没法断定这个过程什么时候会完成，但是相信一旦这只生物苏醒，它会成为远比普通的缇扬奇要大得多，也恐怖得多的存在：这只生物值得我们视作一只新的缇扬奇族母。</p></blockquote><p>触发两个选项，一个是在不干扰的情况下观察和研究，获得大量社会学研究点数，另一个是将其作为样本卖给策展人，获得5k能量币。</p><h2 id="令人熟悉的挖掘"><a href="#令人熟悉的挖掘" class="headerlink" title="令人熟悉的挖掘"></a>令人熟悉的挖掘</h2><p>遗迹。令人不寒而栗</p><h2 id="小行星防爆门"><a href="#小行星防爆门" class="headerlink" title="小行星防爆门"></a>小行星防爆门</h2><p>遗迹，倒还挺常见的，每把都有。<br>第一阶段，钻出一个洞</p><blockquote><p>某种非常巨大的建筑物占据了J3L1-J88小行星的绝大部分内部空间。作为这个建筑物唯一入口的防爆门至今仍无法被打开，但是一条从小行星另一侧的通道已经被挖掘出来。我们的钻头目前仍无法钻透这个建筑物厚实的外壁，但这个方法似乎仍然提供了进入的最佳机会。尽管它们已经过千年风沙，但是防爆门仍然被证实是坚不可摧的。</p></blockquote><p>第二阶段，入口</p><blockquote><p>我们最终还是在J3L1-J88内建筑物的外墙上钻出了一个洞。它的内部是一个宽广的指挥中心，或者是某种地堡，其中零散的散布着几千个腐朽的外星人遗骸。仔细研究这些，将会让我们得到一张关于当年这颗小行星内部所发生事件更为清晰的图片，这也将花费相当长的时间。</p></blockquote><p>第三阶段，指挥中心</p><blockquote><p>这颗小行星曾经作为一个相对较大的星际帝国的隐匿首都，该帝国在数千年前曾经统治着这片星区。<br>有了这样堡垒化的指挥中心，帝国的统治精英们可以与数以千计的军事或民政官员一道安全无虞地发号施令，不受其苛政引起的暴乱所威胁。<br>小行星与帝国的其余部分的联系只依靠加密的亚空间通讯和一艘定期来访以补给基地物资和运送人员的货船来进行。</p></blockquote><h2 id="缇扬奇族母"><a href="#缇扬奇族母" class="headerlink" title="缇扬奇族母"></a>缇扬奇族母</h2><p>敌对BOSS，击杀后触发事件“解剖缇扬奇族母”并放出困于缇扬奇族母体内的一艘战列舰“亚哈船长号”，该舰初始不满血，完整综合效能为279，主要使用鱼雷（因为是炮击作战电脑）。完成“解剖缇扬奇族母”后，首都获得buff”祖姆鞭毛“，在首都每月有机人口<font color="lightgreen">+1</font>，并<font color="red">-5</font>稳定度，事件可以概括为巡游途中鞭毛对周围的人产生了克隆。</p><h2 id="跟随科研舰的太空变形虫母"><a href="#跟随科研舰的太空变形虫母" class="headerlink" title="跟随科研舰的太空变形虫母"></a>跟随科研舰的太空变形虫母</h2><p>拥有“安抚变形虫”的buff时可能产生，可以选择甩掉或者养着，一开始会跟随科研船，可以作为战舰参与战斗，长大后有19的综合效能。可以在给定的名字表中选取名字，因此一般称为“泡泡”，翻名字表到最后可以命名为“毛球”。（但是不会有人把它派上前线吧 都是当宠物养的）</p><h2 id="化石遗骸"><a href="#化石遗骸" class="headerlink" title="化石遗骸"></a>化石遗骸</h2><p>遗迹。<br>初始描述</p><blockquote><p>在第三产业-II上的一个大而与世隔绝的山谷中一些不同物种的化石被发现了，这些物种似乎不是来自该行星的。它们大体上都来自同一个时期，大约是360万年前，跨度为几个世纪的那段时间内。这些物种中的每一个个体似乎都是在其所属的独特的生物圈中进化而来的而且它们似乎都具有智慧。奇怪的是，到目前为止发现的每一个化石都显示出遭到暴力终结的迹象。</p></blockquote><p>第一阶段，更多遗骸</p><blockquote><p>考古学家们在山谷中发掘出了越来越多的化石残骸，到目前为止已经有26种不同的智慧物种了，它们都不是第三产业-II的本士物种。那些保存程度较高，能用于确定死亡原因的化石都表明这些物种死于刀刃予或箭造成的物理创伤。似乎没有任何样本是被现代炮弹或能量武器等类似的装备所击倒的。<br>在山谷入口附近发现了某种小型结构的废墟。它似乎与这些化石来源于同一时期。也许这会使事情变得明朗一些。</p></blockquote><p>第二阶段，小屋</p><blockquote><p>对峡谷入口周边发现的古代建筑结构的发掘工作正按照计划稳步进行中。许多文物被发现，大多数文物似乎是各种狩猎武器和战利品。个被部分翻译的标志似乎是该结构的名字，意为:</p><center>马克维尔之谷一第一狩猎屋</center><p></p></blockquote><p>第三阶段，雷塔拉克斯领域</p><blockquote><p>对狩猎屋周边的持续发掘提供了更多的细节信息。第三产业-II和马克维尔之谷是作为一个被称为雷塔拉克斯领域的星际政体的武士同志阶级的狩猎保留地。雷塔拉克斯是掠夺性的禽类物种，周期性地纳集他们统治下的外星附庸文明的随机个体。这些外星物种按照统治雷塔拉克斯社会的仪式在马克维尔的荒野被狩猎并杀害。</p></blockquote><p>(待续)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 代发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置防盗链</title>
      <link href="/2023/02/3.html"/>
      <url>/2023/02/3.html</url>
      
        <content type="html"><![CDATA[<p>由于打算把图片放在自己的服务器上，所以配置防盗链也成了一个必须完成的任务。</p><p>在网上搜了一下，大致上是利用nginx检测http请求头中的referer参数来判断是否返回图片。</p><pre class="line-numbers language-none"><code class="language-none">location / {    root html/img;    valid_referers none blocked  *.example.com example.com ;    if ($invalid_referer) {        return 403;        break;     }     access_log off;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点在第3行”vaild_referers”的设置。</p><p>根据<a href="http://nginx.org/en/docs/http/ngx_http_referer_module.html#valid_referers">nginx官方文档</a><br>的解释，”valid_referers”的几个参数实际上是几个条件。</p><p>“none”参数表示http header中没有referer,”blocked”表示http header中有referer但被防火墙或者代理服务器删除，<br>后面指定的域名表示在referer中匹配到相应的域名。只要满足以上任意一条，$invalid_referer变量则变为<strong>空字符串</strong>， 否则为1。<br>可以通过判断该变量的值来确定请求是否合法，达到防盗链的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用three.js创建3D场景</title>
      <link href="/2023/02/2.html"/>
      <url>/2023/02/2.html</url>
      
        <content type="html"><![CDATA[<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><ul><li>新建一个空的场景</li><li>添加相机和灯光</li><li>添加各个物体</li><li>创建渲染器</li><li>使用渲染器渲染场景</li></ul><h2 id="新建场景"><a href="#新建场景" class="headerlink" title="新建场景"></a>新建场景</h2><p>直接新建一个场景对象</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">import * as THREE from "three"; //导入const scene = new THREE.Scene();scene.background = new THREE.color(0x0); //背景为黑色，默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="添加相机"><a href="#添加相机" class="headerlink" title="添加相机"></a>添加相机</h2><p>多数情况下使用的相机是透视相机，这种相机模拟人眼的观察，示意图如下，紫色棱台包括的范围内，物体会被渲染<br>(图片来自 <a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene">Rachel Smith</a>)<br><img src="https://cdn.ncmc.me/2023/02/00/00.jpg" alt="透视相机"></p><p>这种相机有个问题：物体在靠近场景边缘的时候会变形。因此我后来采用正交相机。<br>正交相机和透视相机类似，但渲染的空间是个四棱柱。没有图片，自行脑补（懒。</p><p>正交相机使用时要注意渲染范围的长宽比要和场景的长宽比一致，否则物体会变形。（下面的代码中，假设场景的长宽比和窗口的长宽比一致）</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//透视型照相机const camera = new THREE.PerspectiveCamera(    100, //视野角度fov    window.innerWidth / window.innerHeight,//长宽比    0.1,//最近渲染距离(就是near plane到照相机的距离)    1000);//最远渲染距离(类似，far plane)camera.position.z = 35;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//正交照相机let renderWidth = 60;let windowWidth = window.innerWidth,windowHeight = window.innerHeight;const camera = new THREE.OrthographicCamera(  -renderWidth,//渲染左边界  renderWidth,//渲染右边界  renderWidth*windowHeight/windowWidth,//渲染上边界  -renderWidth*windowHeight/windowWidth,//渲染下边界  5,//最近渲染距离  100);//最远渲染距离camera.position.z = 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加灯光"><a href="#添加灯光" class="headerlink" title="添加灯光"></a>添加灯光</h2><p>这玩意还没搞懂，先用着最简单的</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const light = new THREE.AmbientLight(0x404040);scene.add(light);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="添加物体"><a href="#添加物体" class="headerlink" title="添加物体"></a>添加物体</h2><p>添加物体四步走：指定物体类型，指定物体材质，创建物体对象，添加物体到场景。以一个棱长为5的正四棱柱为例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let geometry = new THREE.BoxGeometry(5, 5, 5);//长宽高let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });let box0 =  new THREE.Mesh(geometry, material);scene.add(box0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，创建完geometry、material两个变量不会再被使用，所以创建部分也可以写成一句</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let box0 =  new THREE.Mesh(    new THREE.BoxGeometry(5, 5, 5),     new THREE.MeshBasicMaterial({ color: 0xff0000 }));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建渲染器并渲染场景"><a href="#创建渲染器并渲染场景" class="headerlink" title="创建渲染器并渲染场景"></a>创建渲染器并渲染场景</h2><p>这东西也没研究，照抄官方教程。</p><p>需要提前在网页中创建id为”container”的标签来容纳场景。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);//渲染的大小就是场景的大小document.getElementById("#container").append(renderer.domElement);renderer.render(scene);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这几步都完成以后打开网页，就能看见场景和刚才创建的红色四棱柱了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">Three.js documentation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发笔记 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript压缩和混淆</title>
      <link href="/2023/02/1.html"/>
      <url>/2023/02/1.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JavaScript压缩和混淆？"><a href="#什么是JavaScript压缩和混淆？" class="headerlink" title="什么是JavaScript压缩和混淆？"></a>什么是JavaScript压缩和混淆？</h2><p>开发人员编写JS代码的时候，有许多格式规范，写出来的代码十分易读、方便开发。<br>而各大网站使用的JS代码，多数都是挤成一团的，肉眼看上去毫无章法可言，可读性几乎为零。</p><p>这些让人“不忍直视”的代码，就是被压缩和混淆过的。一般的压缩通常只是除去注释、空行<br>和空格等，而混淆还会将变量名、函数名等替换成一些无意义的字符，还可能会添加一些<br>无意义的代码。</p><h2 id="如何进行压缩和混淆？"><a href="#如何进行压缩和混淆？" class="headerlink" title="如何进行压缩和混淆？"></a>如何进行压缩和混淆？</h2><p>目前比较流行的混淆工具有Uglify和Google Closure Compiler等。在混淆的<br>过程中，工具还会对代码进行优化，有点类似于C语言编译器的预处理。</p><h2 id="压缩、混淆的作用"><a href="#压缩、混淆的作用" class="headerlink" title="压缩、混淆的作用"></a>压缩、混淆的作用</h2><p>主要是提高JavaScript代码的运行效率，缩小代码体积。一定程度上还可以隐藏代码的运行逻辑<br>起到版权保护的作用。</p><h2 id="随便写写"><a href="#随便写写" class="headerlink" title="随便写写"></a>随便写写</h2><p>个人认为压缩、混淆对代码的保护作用十分有限。如果使用的是一般的混淆方法，<br>很容易就能够还原出大致的框架。部分混淆方法混淆的代码甚至可以完整还原出所有变量名。<br>尽管有些比较“变态”的加密工具，如JavaScript Obfuscator，可以真正做到加密代码，<br>但这最多也就是提高逆向成本罢了。如果真的既要保护代码又非得用JS不可，<br>感觉WebAssembly是个比较好的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
