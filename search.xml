<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用three.js创建3D场景</title>
      <link href="/2023/02/3.html"/>
      <url>/2023/02/3.html</url>
      
        <content type="html"><![CDATA[<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><ul><li>新建一个空的场景</li><li>添加相机和灯光</li><li>添加各个物体</li><li>创建渲染器</li><li>使用渲染器渲染场景</li></ul><h2 id="新建场景"><a href="#新建场景" class="headerlink" title="新建场景"></a>新建场景</h2><p>直接新建一个场景对象</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">import * as THREE from "three"; //导入const scene = new THREE.Scene();scene.background = new THREE.color(0x0); //背景为黑色，默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="添加相机"><a href="#添加相机" class="headerlink" title="添加相机"></a>添加相机</h2><p>多数情况下使用的相机是透视相机，这种相机模拟人眼的观察，示意图如下，紫色棱台包括的范围内，物体会被渲染<br>(图片来自 <a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene">Rachel Smith</a>)<br><img src="https://cdn.ncmc.me/2023/02/00/00.jpg" alt="camera"></p><p>这种相机有个问题：物体在靠近场景边缘的时候会变形。因此我后来采用正交相机。<br>正交相机和透视相机类似，但渲染的空间是个四棱柱。没有图片，自行脑补（懒。</p><p>正交相机使用时要注意渲染范围的长宽比要和场景的长宽比一致，否则物体会变形。（下面的代码中，假设场景的长宽比和窗口的长宽比一致）</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//透视型照相机const camera = new THREE.PerspectiveCamera(    100, //视野角度fov    window.innerWidth / window.innerHeight,//长宽比    0.1,//最近渲染距离(就是near plane到照相机的距离)    1000);//最远渲染距离(类似，far plane)camera.position.z = 35;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//正交照相机let renderWidth = 60;let windowWidth = window.innerWidth,windowHeight = window.innerHeight;const camera = new THREE.OrthographicCamera(  -renderWidth,//渲染左边界  renderWidth,//渲染右边界  renderWidth*windowHeight/windowWidth,//渲染上边界  -renderWidth*windowHeight/windowWidth,//渲染下边界  5,//最近渲染距离  100);//最远渲染距离camera.position.z = 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加灯光"><a href="#添加灯光" class="headerlink" title="添加灯光"></a>添加灯光</h2><p>这玩意还没搞懂，先用着最简单的</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const light = new THREE.AmbientLight(0x404040);scene.add(light);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="添加物体"><a href="#添加物体" class="headerlink" title="添加物体"></a>添加物体</h2><p>添加物体四步走：指定物体类型，指定物体材质，创建物体对象，添加物体到场景。以一个棱长为5的正四棱柱为例：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let geometry = new THREE.BoxGeometry(5, 5, 5);//长宽高let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });let box0 =  new THREE.Mesh(geometry, material);scene.add(box0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，创建完geometry、material两个变量不会再被使用，所以创建部分也可以写成一句</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let box0 =  new THREE.Mesh(    new THREE.BoxGeometry(5, 5, 5),     new THREE.MeshBasicMaterial({ color: 0xff0000 }));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建渲染器并渲染场景"><a href="#创建渲染器并渲染场景" class="headerlink" title="创建渲染器并渲染场景"></a>创建渲染器并渲染场景</h2><p>这东西也没研究，照抄官方教程。</p><p>需要提前在网页中创建id为”container”的标签来容纳场景。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);//渲染的大小就是场景的大小document.getElementById("#container").append(renderer.domElement);renderer.render(scene);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这几步都完成以后打开网页，就能看见场景和刚才创建的红色四棱柱了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">Three.js documentation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发笔记 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript压缩和混淆</title>
      <link href="/2023/02/2.html"/>
      <url>/2023/02/2.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JavaScript压缩和混淆？"><a href="#什么是JavaScript压缩和混淆？" class="headerlink" title="什么是JavaScript压缩和混淆？"></a>什么是JavaScript压缩和混淆？</h2><p>开发人员编写JS代码的时候，有许多格式规范，写出来的代码十分易读、方便开发。<br>而各大网站使用的JS代码，多数都是挤成一团的，肉眼看上去毫无章法可言，可读性几乎为零。</p><p>这些让人“不忍直视”的代码，就是被压缩和混淆过的。一般的压缩通常只是除去注释、空行<br>和空格等，而混淆还会将变量名、函数名等替换成一些无意义的字符，还可能会添加一些<br>无意义的代码。</p><h2 id="如何进行压缩和混淆？"><a href="#如何进行压缩和混淆？" class="headerlink" title="如何进行压缩和混淆？"></a>如何进行压缩和混淆？</h2><p>目前比较流行的混淆工具有Uglify和Google Closure Compiler等。在混淆的<br>过程中，工具还会对代码进行优化，有点类似于C语言编译器的预处理。</p><h2 id="压缩、混淆的作用"><a href="#压缩、混淆的作用" class="headerlink" title="压缩、混淆的作用"></a>压缩、混淆的作用</h2><p>主要是提高JavaScript代码的运行效率，缩小代码体积。一定程度上还可以隐藏代码的运行逻辑<br>起到版权保护的作用。</p><h2 id="随便写写"><a href="#随便写写" class="headerlink" title="随便写写"></a>随便写写</h2><p>个人认为压缩、混淆对代码的保护作用十分有限。如果使用的是一般的混淆方法，<br>很容易就能够还原出大致的框架。部分混淆方法混淆的代码甚至可以完整还原出所有变量名。<br>尽管有些比较“变态”的加密工具，如JavaScript Obfuscator，可以真正做到加密代码，<br>但这最多也就是提高逆向成本罢了。如果真的既要保护代码又非得用JS不可，<br>感觉WebAssembly是个比较好的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
