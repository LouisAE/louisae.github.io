<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++类与对象之析构函数</title>
      <link href="/2023/05/34611.html"/>
      <url>/2023/05/34611.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在对象被撤销时，清理对象的内存。然而析构函数并不能释放对象占用的内存，只是事先做一些清理的工作。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>函数名和类名一致，以~开头，没有返回值，不带参数。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Myclass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token operator">~</span><span class="token function">Myclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//或者</span>        <span class="token comment">//~Myclass() {};</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>附注：在新版本C++中，建议使用noexcept关键字，表示析构函数不会抛出异常。如果使用新版本编译器，没有使用该关键字的析构函数会被自动加上该关键字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编中物理地址的合成方式</title>
      <link href="/2023/03/20524.html"/>
      <url>/2023/03/20524.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在自学汇编语言的同时，学校也在上“微机原理与应用”这门课。感觉学这类东西还是要结合实验，<br>不然像现在的“微机原理”课一样，很多东西非常抽象，光看书根本无法理解。关于8086处理器对地址的处理，虽然感觉这部份应该很好理解，但是为了巩固印象，水一篇文章总结一下。</p><h2 id="8086中地址的处理方式及原因"><a href="#8086中地址的处理方式及原因" class="headerlink" title="8086中地址的处理方式及原因"></a>8086中地址的处理方式及原因</h2><p>8086处理器使用 “段地址：偏移地址” 的方式表示地址。例如：073F:0000表示073F00这个物理地址，其中段地址和偏移地址都是16位的数字。<br>事实上，8086处理器中的地址加法器会把段地址乘16，再与偏移地址相加以合成物理地址。例如073F:0005对应的物理地址是073FH * 10H + 5H = 073F5H。(H表示16进制)。</p><p>之所以用这种看起来啰哩啰唆的方式表示地址，是因为8086处理器有20根地址总线，可以传送20位地址，<br>然而，8086处理器是16位处理器，一次只能处理16位的数据，所以要依靠两个16位的数据来间接表示20位的地址。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果足够细心，就会发现这种寻址方式存在一个有趣的问题：如果偏移地址不止一个十六进制位，会出现什么情况呢？</p><p>假设有一个地址：073F:0022,按照上面的方式合成物理地址：073FH * 10H + 22H = 07412H。看起来，这个地址也可以写成0741:0002。这两种写法都是正确的。</p><p>实际上，同一个物理地址对应多个“段地址：偏移地址”。只要按照正确的法则合成物理地址，就不会出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搓一个语音唤醒</title>
      <link href="/2023/03/56157.html"/>
      <url>/2023/03/56157.html</url>
      
        <content type="html"><![CDATA[<p>（非原创，代某位卷王发送）</p><hr><p>（哈哈 这个排版 稀烂咯）</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>搓一个语音唤醒（keyword spotting），用于上课时摸鱼，老师点名时可以做出提醒，并且保留点名前后的一部分音频（毕竟还得知道为啥点你）。只需要识别名字，因此输入长度为1秒左右，约为两到四个音节，输出为两个类别的概率。计划采用简单的CNN+线性，将图输入进来卷积+池化然后激活，过两遍，采用适应性池化压缩为$图数\times1\times1$的向量，进两层线性+激活，最后输出为二维向量。</p><h2 id="首先做出图像来"><a href="#首先做出图像来" class="headerlink" title="首先做出图像来"></a>首先做出图像来</h2><p>取一个音轨，使用快速傅里叶变换来将音频变成频谱图。首先，用<code>torchaudio.load来load一个.wav</code>，返回第一个参数是波形，第二个是采样率，用<code>torchaudio.transforms.MelSpectrogram(这里填上面解析出来的波形)</code>（梅尔图）。其实最好输入前做个滤波之类的预处理，我是因为训练的时候发现有大量的极大值（其他都是零点几，有几个10几的）所以用了些奇怪的函数来（就是log的一个变形），然后进行一个归一化（用的是最大最小值归一化）</p><h2 id="然后丢给神经网络，先组一个网络"><a href="#然后丢给神经网络，先组一个网络" class="headerlink" title="然后丢给神经网络，先组一个网络"></a>然后丢给神经网络，先组一个网络</h2><p>由于没有经验，加上torch本身的教程和中文教程都大同小异地看不懂，所以一边摸索一边做（但是笔记是写完才做的。。。所以基本上忘记踩了什么坑了 悲）<br>aF采用elu函数（变形的泄露relu），卷积层1为<u>1层入4层出7核格宽</u>，经过(2,2)的最大池化，卷积层2为<u>4层入6层出5核格宽</u>，经过AdaptiveMaxPool2d变为$6\times1\times1$向量，线性层1<u>输入6输出8</u>，线性层2<u>输入8输出2</u>，net本身结构为</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token operator">=</span>maxPool<span class="token punctuation">(</span>aF<span class="token punctuation">(</span>cov1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>adaptivePool<span class="token punctuation">(</span>aF<span class="token punctuation">(</span>cov2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#这个是压缩为二维向量</span>    x<span class="token operator">=</span>aF<span class="token punctuation">(</span>linear1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token operator">=</span>sigmoid<span class="token punctuation">(</span>linear2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#主要是考虑到这是个概率，所以用个sigmoid变换到0~1</span>    <span class="token keyword">return</span> x</code></pre><h2 id="前向和反向"><a href="#前向和反向" class="headerlink" title="前向和反向"></a>前向和反向</h2><p>首先先将输入的东西变成tensor，丢进去forward输出用个概率，和标准比对，开始是反向更新。首先先重置优化器的梯度，optimizer用的是optim.SGD(net.parameters(),lr)，其中net.parameters()是需要更新的参数，lr是learningRate（具体参数自己找pytorch，笑死，毫无指引）。loss采用交叉熵<code>nn.CrossEntropyLoss</code>，参数为两个float，我是把两个tensor给.float再导进去。然后对loss进行一个.backward()来取梯度，再optimizer.step()来进行一个步进更新。我最后面返回了一个loss.item()，问题是这个是啥我还没看懂，说是loss但是很不平滑。</p><h2 id="将音频流切片丢进去判断有没有激活"><a href="#将音频流切片丢进去判断有没有激活" class="headerlink" title="将音频流切片丢进去判断有没有激活"></a>将音频流切片丢进去判断有没有激活</h2><p>就是验证部分，取了数据集里面的另一部分来进行检验，我做出来是0.93的准确率。</p><h2 id="从外部输入音频流"><a href="#从外部输入音频流" class="headerlink" title="从外部输入音频流"></a>从外部输入音频流</h2><p>使用pyaudio库。首先是用<code>audio=pyaudio.PyAudio()</code>初始化一个类变量，调用函数<code>stream=audio.open(参数)</code>进行初始化设置，调用<code>data=stream.read(参数)</code>来获取音频流，音频流是记为两位十六进制数的二进制字符串，我是用<code>np.frombuffer(stream.read(这里是frames_per_buffer),dtype=np.float32)</code>来变换的，记得因为是实时音频流所以写while里面，至于这堆二进制怎么变成波形图就靠np罢（称赞一下写综述的大大，该方法经过一系列采坑后通过<a href="zhuanlan.zhihu.com/p/611234973">综述</a>找到的。<br>采集设备也比较重要，好的麦克风可以先处理掉一部分噪声，收音也更集中。一开始用耳麦做的时候噪点非常多，回来换了舍友的麦之后梅尔图干净了不少。但是还是有个问题，我是按处理.wav输入的方式处理<code>np.frombuffer</code>解析的数据，既把它的返回直接当成时域的信号，清洗后输入转换成梅尔图，再与先前获取的底噪的梅尔图相减。结果上看，结果归一化后，较大值比较多，较小值比较少，与从.wav中获取的梅尔图恰相反。</p><h2 id="遇到的问题（只能想起一些li）"><a href="#遇到的问题（只能想起一些li）" class="headerlink" title="遇到的问题（只能想起一些li）"></a>遇到的问题（只能想起一些li）</h2><p>比如说最开始的梅尔图，会导致输入的图大部分数在0~1少部分在10以上或者-10以下，归一化之后就会导致大部分数挤在中间（当然，你不归一化就没有这个烦恼了 大概 我懒得优化了 <del>反正也是堆屎山</del>），所有没用原本的log2函数，而且有负数，所以考虑了用有负数部分的泄露relu函数变形。<br>然后还有就是如果发现自己训练的RC比例和样本比例相同那可能就是你样本有问题（别问我怎么知道的），我训练目标用的是<a href="http://www.openslr.org/85/">北京希尔贝壳的HIMIA数据集</a>（吐槽一下，我发现为什么英文只有女声，是我查找的问题吗？），训练的非目标样本是随便截的音频。<br>我使用<code>nn.AdaptiveMaxPool2d</code>是考虑了输入的音频长度可能有一定范围的差别，所以加的，你当然可以不加，你喜欢的话awa<br>一开始做那个外部音频流的时候就只找到pyaudio能采集，然后一开始用np.fromstring来处理二进制发现经过很奇怪，没法转换到tensor中进行MelSpectrogram，所以又试了wave库，本来要试ffmpeg的，结果发现Python上的ffmpeg库是只能处理视频的半成品，然后就放弃了去查综述。<br>MelSpectrogram的语法是<code>MelSpectrogram(参数)(tensor形式的输入)</code>，如果报了int is not callable之类的（具体忘了x）那应该是MelSpectrogram的输入你搞错了，请检查一下输入是否为tensor，以及维度（？这个不确定会不会是）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 代发 </tag>
            
            <tag> 开发笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再游湖畔</title>
      <link href="/2023/03/35335.html"/>
      <url>/2023/03/35335.html</url>
      
        <content type="html"><![CDATA[<p>子在川上曰：“逝者如斯夫，不舍昼夜”。时间如河水一般滚滚流去，曾经熟悉的事物所发生的变化也大得让人吃惊。</p><p>时隔两个月，我又一次循着熟悉的湖边小路散步。拦腰高的石头围栏，被齐胸高、涂着黑灰色油漆的铁制栏杆所取代。<br>和两个月前相比，本就很低的水位变得更低了。原本靠近湖岸的浅滩被剥去外衣，露出崎岖不平的身躯。<br>长在湖的一角的一片矮竹林被连根拔起装进垃圾袋，随意地放在路旁。这片林子曾经充满了鸟儿们的欢声笑语。</p><p><img src="https://cdn.ncmc.me/2023/03/00/00.jpg" alt="路旁的遗弃物"></p><p>在另一个角落，我发现了那些被替换掉、兢兢业业几十载的石围栏的最终归宿——它们躺在水里一言不发，不知是嘲讽，抑或是悲哀。</p><p><img src="https://cdn.ncmc.me/2023/03/00/01.jpg" alt="水中石柱"></p><p>距离上一次在湖畔散步不过数周，在某位领导的脑子一热、大腿一拍之下，这片湖就发生了如此大的变化。实在不得不感慨世事难料。静止的事物尚且如此，人就更过之而无不及了。也不知下次再见到那位临走时说”我没有家“的特殊的女孩子的时候，她是否也会发生如此大的变化呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王爽《汇编语言》实验5 (5)</title>
      <link href="/2023/02/17545.html"/>
      <url>/2023/02/17545.html</url>
      
        <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>编写code段中的代码，将a段和b段数据依次相加，结果存入c段</p><pre class="language-none"><code class="language-none">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c endscode segmentstart:？？？？？？？    mov ax,4c00h    int 21hcode endsend start</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题有三个数据段，但是段寄存器只有ds,es两个。。。手上这本旧课本的主人写的笔记是拿ss当第三个<br>段寄存器，这。。。应该不行吧？想破头也想不通，遂谷歌之。</p><p>其中一种解决思路是引入更多的寄存器。比如si,di等。因为之前没有接触过这类寄存器，<br>不知道使用上有什么讲究，因此不采用这种思路。</p><p>还有一种思路是利用栈暂存段寄存器中的数据，暂时更改段寄存器指向的段，后面再恢复成原来的值。</p><p>核心代码:</p><pre class="language-none"><code class="language-none">push dsmov ax,cmov ds,ax......pop ds</code></pre><p>这种思路虽然效率不太好，但是知识范围没有超纲。</p><p>最终代码如下</p><pre class="language-none"><code class="language-none">  mov ax,a  mov ds,ax  mov ax,b  mov es,ax  mov ax,0  mov bx,0  s:mov al,[bx]  add al,es:[bx]  push ds  mov dx,c  mov ds,dx  mov [bx],ax  pop ds  inc bx  loop s    mov ax,4c00h  int 21h</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>调试过程中，曾经利用ax来作为偏移量寻址，类似 mov bl,[ax] 这样的，但是编译时报错，<br>查阅资料发现16位处理器不能使用ax寻址，原因不知道。（书上貌似没写）（补充：在后面第8章写了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开端</title>
      <link href="/2023/02/21985.html"/>
      <url>/2023/02/21985.html</url>
      
        <content type="html"><![CDATA[<p>开学了。</p><p>恰是春季，尽管还有些许寒意，也难掩生机勃勃。曾经因封控而变得冷清的街道，也恢复了往日的繁荣。</p><p>火车站一如既往，不一样的是车站大门口悬挂的写着“请出示健康码”的牌子不见了，那些低头操作手机寻找健康码、堵住通道的旅客没有了。<br>候车大厅也似乎比过去更热闹了。</p><p><img src="https://cdn.ncmc.me/2023/02/02/00.jpg" alt="火车站"></p><p>不知是常态还是今天乘客带的行李特别多，上了高铁，就看见乘务员们为了乘客们的行李前后忙活。时而大声询问不按规定放置、堵塞通道的行李属于哪位乘客，<br>时而挪开堵住车内洗手间门的行李箱。好不容易才在车开之前，把所有的大件行李都放到合适的位置。</p><p>进了校门，一度设置在门后，检查返校生健康证明和健康申报结果的关卡早已不见踪影。<br>站在一个又一个遮雨棚接起来形成的长长的通道入口，可以毫无阻拦地看见另一端的出口。</p><p>总感觉乌云散去后露出的天空特别蓝，天朗气清，微风拂面。</p><p>真惬意啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群星异闻录</title>
      <link href="/2023/02/48452.html"/>
      <url>/2023/02/48452.html</url>
      
        <content type="html"><![CDATA[<h1 id="群星异闻录"><a href="#群星异闻录" class="headerlink" title="群星异闻录"></a><span style="display:block;text-align:center;color:lightblue;">群星异闻录</span></h1><p>本文非原创，是代替某卷王存档的文章</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本书用于记录作为第四天灾时，游走在星际之间的见闻与事件，事件不一定都是原版的，遇到的事件也是随机的，因此不一定能记录完整。部分文案为手打，可能存在错漏，部分事件名为主观命名。</p><h2 id="阿斯特莱雅遗迹"><a href="#阿斯特莱雅遗迹" class="headerlink" title="阿斯特莱雅遗迹"></a>阿斯特莱雅遗迹</h2><p>本事件应该属于伞mod，挖掘遗迹所触发的事件，事件结束后获得一名科学家和一个遗珍。<font color="darkorchid">遗珍</font>为伞の奇怪脑袋（问号凯露头）；替换挖掘遗迹的科学家为多多良小鼬，多多良小鼬额外有用<font color="#41C3E5">伞鼬</font>和<font color="#41C3E5">奇怪的异色瞳</font>两个属性，<font color="#41C3E5">伞鼬</font>给予航速提升和不朽，<font color="#41C3E5">奇怪的异色瞳</font>给予调查速度和考古速度提升。</p><h2 id="大的药"><a href="#大的药" class="headerlink" title="大的药"></a>大的药</h2><p>准确来说，这是一个物品，一个<font color="darkorchid">遗珍</font>，应该属于伞mod。一颗红黄的药丸，无被动效果，激活效果标注为“不要使用这个东西”，用红色的字标注“这是个陷阱”，底下用彩色的字写有“点下去”。启动消耗100影响力，启用后游戏崩溃闪退。</p><h2 id="缇扬奇乱坟岗"><a href="#缇扬奇乱坟岗" class="headerlink" title="缇扬奇乱坟岗"></a>缇扬奇乱坟岗</h2><p>在地图中有一群缇扬奇会守着一个星球，为遗迹。该掘遗迹有4个阶段和一个前置。前置要求杀死守墓的缇扬奇，缇扬奇群战力约200+，或者用工程船搭建一个缇扬奇诱饵吸引守墓的缇扬奇。<br>第一阶段，肉之球</p><blockquote><p>我们实在是很难说奥列克-伍尔到底算不算作一个行星: 初步钻探发现的是一层又一层的生物组织。据估计，总共需要2,435,463只提扬奇尸体才能产生此等规模的行星(质量误差范围5.3%)。即使我们假设地核是一块岩石，尸体只是堆叠在上面，涉及到的样本数量依然是无比庞大的。是某人或者某种事物将绕扬奇带到这里让它们死去，还是说它们只是顺其白然地来到这里度过品后的时光。然后死去?</p></blockquote><p>第二阶段，死亡三步</p><blockquote><p>遍布奥列克-伍尔地表的死亡堤扬奇的那种不寻常·….·的活动，似乎是它们再生能力的一种副作用: 即使技术上已经判定为死亡，它们的尸体仍旧在不断地重组再生。这个恒星系拥有着非比寻常般丰富的营养物质，尤其是堤扬奇游荡的那个气态巨行星。或许这解释了为什么我们之前从未观察到这样的行为。然而，这个发现并没有解释为什么这些死去的生物像是在被某种单一思维控制一样蠕动，不断地伸出触手，吞食新近降落到这个行星上的尸体。</p></blockquote><p>第三阶段，尸山血海迷宫</p><blockquote><p>我们的挖掘队发掘到了一个复杂的隧道网络，从奥列克-伍尔的地表一直延<br>伸到地下深处。化学分析确认迷宫的墙体是由压实的绕扬奇组织构成，尽管其年代甚至超过了我们的帝国，但肉质还散发着温热，甚至几乎没有腐败。看上去就像是这些尸体自己聚合到了一起，重构其形态建立了这个地方·…·但是为什么?</p></blockquote><p>第四阶段，隧道魅影</p><blockquote><p>在对奥列克-伍尔的地下隧道网络进行测绘的时候，我们的科学家突然意识到，这个隧道网络同一只提扬奇的血管系统极其相似一一但是其规模跟我们之前遇到的那只在星辰间游荡的缇扬奇族母差不多。那些搏动的墙壁散发着轻微的温暖，随着探险队逐渐接近行星的核心，墙壁的温度也在慢慢提升一一在核心处，我们的扫描仪捕捉到了一个微弱的生命信号。</p></blockquote><p>第四阶段，主脑</p><blockquote><p>在一个庞大的地下穴室中，一只缇扬奇竖立地站着，钟型的脑袋微微地摇晃着，它细线一样的触手舒展开来，连接着穴室的外墙。看上去它成为了某种控制单元，不断操纵、指引着这个行星级别墓地的生长。我们的科学家没法断定这个过程什么时候会完成，但是相信一旦这只生物苏醒，它会成为远比普通的缇扬奇要大得多，也恐怖得多的存在：这只生物值得我们视作一只新的缇扬奇族母。</p></blockquote><p>触发两个选项，一个是在不干扰的情况下观察和研究，获得大量<font color="#71C96D">社会学研究点数</font>，另一个是将其作为样本卖给策展人，获得<font color="#E5C100">5k能量币</font>。</p><h2 id="令人熟悉的挖掘"><a href="#令人熟悉的挖掘" class="headerlink" title="令人熟悉的挖掘"></a>令人熟悉的挖掘</h2><p>遗迹。令人不寒而栗</p><h2 id="小行星防爆门"><a href="#小行星防爆门" class="headerlink" title="小行星防爆门"></a>小行星防爆门</h2><p>遗迹，倒还挺常见的，每把都有。<br>第一阶段，钻出一个洞</p><blockquote><p>某种非常巨大的建筑物占据了J3L1-J88小行星的绝大部分内部空间。作为这个建筑物唯一入口的防爆门至今仍无法被打开，但是一条从小行星另一侧的通道已经被挖掘出来。我们的钻头目前仍无法钻透这个建筑物厚实的外壁，但这个方法似乎仍然提供了进入的最佳机会。尽管它们已经过千年风沙，但是防爆门仍然被证实是坚不可摧的。</p></blockquote><p>第二阶段，入口</p><blockquote><p>我们最终还是在J3L1-J88内建筑物的外墙上钻出了一个洞。它的内部是一个宽广的指挥中心，或者是某种地堡，其中零散的散布着几千个腐朽的外星人遗骸。仔细研究这些，将会让我们得到一张关于当年这颗小行星内部所发生事件更为清晰的图片，这也将花费相当长的时间。</p></blockquote><p>第三阶段，指挥中心</p><blockquote><p>这颗小行星曾经作为一个相对较大的星际帝国的隐匿首都，该帝国在数千年前曾经统治着这片星区。<br>有了这样堡垒化的指挥中心，帝国的统治精英们可以与数以千计的军事或民政官员一道安全无虞地发号施令，不受其苛政引起的暴乱所威胁。<br>小行星与帝国的其余部分的联系只依靠加密的亚空间通讯和一艘定期来访以补给基地物资和运送人员的货船来进行。</p></blockquote><p>第四阶段，最后时日</p><blockquote><p>从拼凑的数据来看，这艘补给货船似乎是由于推进器故障而与小行星相撞的。<br>碰撞产生的爆炸破坏力防爆门，并摧毁了小行星的亚空间发射器，永久地切断了它与外界的所有联系。<br>陷入了困境，更没有得救的希望，小行星的居民慢慢地死于饥饿或自杀。他们唯一残存的子空间接收器的最后日志证实，他们的帝国突然失去了首都，随后陷入内战和混乱中。</p></blockquote><h2 id="缇扬奇族母"><a href="#缇扬奇族母" class="headerlink" title="缇扬奇族母"></a>缇扬奇族母</h2><p>敌对BOSS，击杀后触发事件“解剖缇扬奇族母”并放出困于缇扬奇族母体内的一艘战列舰“亚哈船长号”，该舰初始不满血，完整综合效能为279，主要使用鱼雷（因为是炮击作战电脑）。完成“解剖缇扬奇族母”后，首都获得buff”祖姆鞭毛“，在首都每月有机人口<font color="#83D883">+1</font>，并<font color="red">-5</font>稳定度，事件可以概括为巡游途中鞭毛对周围的人产生了克隆。</p><h2 id="跟随科研舰的太空变形虫母"><a href="#跟随科研舰的太空变形虫母" class="headerlink" title="跟随科研舰的太空变形虫母"></a>跟随科研舰的太空变形虫母</h2><p>拥有“安抚变形虫”的buff时可能产生，可以选择甩掉或者养着，一开始会跟随科研船，可以作为战舰参与战斗，长大后有19的综合效能。可以在给定的名字表中选取名字，因此一般称为“泡泡”，翻名字表到最后可以命名为“毛球”。</p><p class="hideblack">（但是不会有人把它派上前线吧 都是当宠物养的）</p><p></p><h2 id="化石遗骸"><a href="#化石遗骸" class="headerlink" title="化石遗骸"></a>化石遗骸</h2><p>遗迹。<br>初始描述</p><blockquote><p>在███████上的一个大而与世隔绝的山谷中一些不同物种的化石被发现了，这些物种似乎不是来自该行星的。它们大体上都来自同一个时期，大约是360万年前，跨度为几个世纪的那段时间内。这些物种中的每一个个体似乎都是在其所属的独特的生物圈中进化而来的而且它们似乎都具有智慧。奇怪的是，到目前为止发现的每一个化石都显示出遭到暴力终结的迹象。</p></blockquote><p>第一阶段，更多遗骸</p><blockquote><p>考古学家们在山谷中发掘出了越来越多的化石残骸，到目前为止已经有26种不同的智慧物种了，它们都不是███████的本士物种。那些保存程度较高，能用于确定死亡原因的化石都表明这些物种死于刀刃予或箭造成的物理创伤。似乎没有任何样本是被现代炮弹或能量武器等类似的装备所击倒的。<br>在山谷入口附近发现了某种小型结构的废墟。它似乎与这些化石来源于同一时期。也许这会使事情变得明朗一些。</p></blockquote><p>第二阶段，小屋</p><blockquote><p>对峡谷入口周边发现的古代建筑结构的发掘工作正按照计划稳步进行中。许多文物被发现，大多数文物似乎是各种狩猎武器和战利品。一个被部分翻译的标志似乎是该结构的名字，意为:</p><center>马克维尔之谷一第一狩猎屋</center><p></p></blockquote><p>第三阶段，雷塔拉克斯领域</p><blockquote><p>对狩猎屋周边的持续发掘提供了更多的细节信息。███████和马克维尔之谷是作为一个被称为雷塔拉克斯领域的星际政体的武士同志阶级的狩猎保留地。雷塔拉克斯是掠夺性的禽类物种，周期性地纳集他们统治下的外星附庸文明的随机个体。这些外星物种按照统治雷塔拉克斯社会的仪式在马克维尔的荒野被狩猎并杀害。</p></blockquote><h2 id="外星生物标本收集"><a href="#外星生物标本收集" class="headerlink" title="外星生物标本收集"></a>外星生物标本收集</h2><p>科研任务，要在领土内调查7种生物。任务描述为</p><blockquote><p>███████的外太空生物博物馆发来请求，他们想请求帮助收集在各个星球上鉴别出的一些稀有外星生命体。</p></blockquote><p>幻影般的塔布拉克<br>强大的塔萨古德</p><blockquote><p>塔萨古德是一种十分致命的捕食者。<br>每当夜晚降临，他们便蛰伏在███████的密林之中，用电击来麻痹他们的猎物，接着便用吸管一样的嘴吸食猎物的大脑。<br>不幸的是，三个█████船员连一个塔萨古德的样本都没有捕获到就被它们给消灭了。<br>为了表彰这些勇敢的船员，███████的外星生物博物馆会用他们的名字来重新命名建筑的一翼。</p></blockquote><p>卑鄙的欧林提</p><blockquote><p>欧林提是一种█████████当地的小型啮齿类生物，他们的居住站已经蔓延到行星大部分的地区。<br>他们以惊人的速率繁殖后代，而且它们似乎有啃食电缆的癖好。<br>收集欧林提的样本并不麻烦。<br>事实上，在完成首批收集之后，更多的欧林提通过搭乘科学飞船的轨道穿梭机偷渡到了███████。<br>至于为何宇宙生物博物馆会要欧林提这种样本，其原因还是个谜。</p></blockquote><p class="hideblack">对啊 为什么啊</p><p>阴险的萨尼兰<br>坚韧的古兰萨</p><blockquote><p>古兰萨是一种巨大、扁平的食草动物，它们体内有气囊，这使得它们能悬浮在离地表几厘米的地方。<br>它们总是成群结队地行动，在█████████多风的平原上吃苔藓和地衣。古兰萨正在被卫星的顶端捕食者无情地猎杀。<br>我们█████上的生物学家预计，只有大约百来群的古兰萨还活着。<br>这当中的一群——由九头古兰萨组成，已经被成功地收集并带回了███████。</p></blockquote><p>狡猾的乌杜兰</p><blockquote><p>███████的船员成功地在█████████的冰层上收集到了一小群的乌杜兰。这些毛茸茸的白色杂食动物把自己滚成一个球，以惊人的速度滚过行星的雪原一一经测量，其中一只的速度竟达到了80公里每小时。我们之所以能侦测到它们是因为它们所到之处都会扬起阵阵飞雪。</p></blockquote><p>贪婪的祖卡</p><blockquote><p>祖卡是群居的虫类生物，它们体型巨大，且以地里的岩石和矿物等无机物为食，这两个特点都足够让人瞠目结舌。<br>一艘█████████的穿梭机遭受重大损失。<br>当时该穿梭机只是不经意间经过了一群祖卡身边，却招致祖卡聚集而来蚕食舰体。<br>在█████的外星生物博物馆已经开始建造关住这种生物的特制容器。</p></blockquote><h2 id="埃迪克巨石"><a href="#埃迪克巨石" class="headerlink" title="埃迪克巨石"></a>埃迪克巨石</h2><blockquote><p>朱鲁VII无人居住，也确实无法居住，但却并非无人造访过。<br>它的表面散布着许多高耸的尖碑，由某种非本星的矿物雕刻，显然是由某种热衷艺术的太空文明所置放于此。<br>这些碑塔流动的曲线雕琢出了一段如此如梦似幻的历史，其一定是虚拟的。<br>一定是。</p></blockquote><p>只有一个选项“拍摄后存入档案”，无意间触发的，也有注意触发条件，但是他最后那个“一定是”就很意味深长。</p><h1 id="说客"><a href="#说客" class="headerlink" title="说客"></a>说客</h1><blockquote><p>星海共同体中夹杂着一阵不和谐的杂音，不是所有人都很友好，肯定地说这其中必有与█████的利益不一致的人。<br>不妙的是，大使██████████似乎正在听取某种错误的声音。<br>在参加由全能██学团体主办的几场会议中，他们的眉毛止不住地上翘。<br>现在一切都水落石出了，一笔可以追溯到某个组织的巨款被查明汇入了他们的账户。<br>█████的同事们要求将他们召回并发起不信任议案。<br>然而，某些更为狡诈的顾问建议我们和他们达成一笔交易，维持其现有职位以换取获得情报的机会。</p></blockquote><p>我是选择把他们召回，相当于冻结这个外交官1080天。如果不召回的话，会按百分比减在星海共同体的权重，减不起。不过有一说一，这个事件发生我才注意到，怎么极端理性里面会有神学团体？</p><h2 id="紫雨"><a href="#紫雨" class="headerlink" title="紫雨"></a>紫雨</h2><blockquote><p>由███████的地表探测器拍摄的朱鲁IIIa上迷人紫雨的图像，辗转流传到██████的文化精英手中。<br>虽然这个发现毫无科研价值，但令人浮想联翩的斑斓降雨图像在██的艺术领域依然擦出了一点复兴的火花，这一事件也许多年之后才会开花结果。</p></blockquote><p>该事件会给予20年的幸福度<font color="#83D883">+10%</font>buff——受启发的艺术。虽然但是，p社又懒得画紫雨，拿孢子事件的图糊弄我，而且该事件到目前为止还没有后续。</p><h1 id="圣夜绝域事件链"><a href="#圣夜绝域事件链" class="headerlink" title="圣夜绝域事件链"></a>圣夜绝域事件链</h1><h1 id="远古机器人星球"><a href="#远古机器人星球" class="headerlink" title="远古机器人星球"></a>远古机器人星球</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 代发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置防盗链</title>
      <link href="/2023/02/53518.html"/>
      <url>/2023/02/53518.html</url>
      
        <content type="html"><![CDATA[<p>由于打算把图片放在自己的服务器上，所以配置防盗链也成了一个必须完成的任务。</p><p>在网上搜了一下，大致上是利用nginx检测http请求头中的referer参数来判断是否返回图片。</p><pre class="language-none"><code class="language-none">location / {    root html/img;    valid_referers none blocked  *.example.com example.com ;    if ($invalid_referer) {        return 403;        break;     }     access_log off;}</code></pre><p>重点在第3行”vaild_referers”的设置。</p><p>根据<a href="http://nginx.org/en/docs/http/ngx_http_referer_module.html#valid_referers">nginx官方文档</a><br>的解释，”valid_referers”的几个参数实际上是几个条件。</p><p>“none”参数表示http header中没有referer,”blocked”表示http header中有referer但被防火墙或者代理服务器删除，<br>后面指定的域名表示在referer中匹配到相应的域名。只要满足以上任意一条，$invalid_referer变量则变为<strong>空字符串</strong>， 否则为1。<br>可以通过判断该变量的值来确定请求是否合法，达到防盗链的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用three.js创建3D场景</title>
      <link href="/2023/02/36984.html"/>
      <url>/2023/02/36984.html</url>
      
        <content type="html"><![CDATA[<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><ul><li>新建一个空的场景</li><li>添加相机和灯光</li><li>添加各个物体</li><li>创建渲染器</li><li>使用渲染器渲染场景</li></ul><h2 id="新建场景"><a href="#新建场景" class="headerlink" title="新建场景"></a>新建场景</h2><p>直接新建一个场景对象</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">import * as THREE from "three"; //导入const scene = new THREE.Scene();scene.background = new THREE.color(0x0); //背景为黑色，默认值</code></pre><h2 id="添加相机"><a href="#添加相机" class="headerlink" title="添加相机"></a>添加相机</h2><p>多数情况下使用的相机是透视相机，这种相机模拟人眼的观察，示意图如下，紫色棱台包括的范围内，物体会被渲染<br>(图片来自 <a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene">Rachel Smith</a>)<br><img src="https://cdn.ncmc.me/2023/02/00/00.jpg" alt="透视相机"></p><p>这种相机有个问题：物体在靠近场景边缘的时候会变形。因此我后来采用正交相机。<br>正交相机和透视相机类似，但渲染的空间是个四棱柱。没有图片，自行脑补（懒。</p><p>正交相机使用时要注意渲染范围的长宽比要和场景的长宽比一致，否则物体会变形。（下面的代码中，假设场景的长宽比和窗口的长宽比一致）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//透视型照相机</span><span class="token keyword">const</span> camera <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">THREE<span class="token punctuation">.</span>PerspectiveCamera</span><span class="token punctuation">(</span>    <span class="token number">100</span><span class="token punctuation">,</span> <span class="token comment">//视野角度fov</span>    window<span class="token punctuation">.</span>innerWidth <span class="token operator">/</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">,</span><span class="token comment">//长宽比</span>    <span class="token number">0.1</span><span class="token punctuation">,</span><span class="token comment">//最近渲染距离(就是near plane到照相机的距离)</span>    <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最远渲染距离(类似，far plane)</span>camera<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span></code></pre><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">//正交照相机let renderWidth = 60;let windowWidth = window.innerWidth,windowHeight = window.innerHeight;const camera = new THREE.OrthographicCamera(  -renderWidth,//渲染左边界  renderWidth,//渲染右边界  renderWidth*windowHeight/windowWidth,//渲染上边界  -renderWidth*windowHeight/windowWidth,//渲染下边界  5,//最近渲染距离  100);//最远渲染距离camera.position.z = 20;</code></pre><h2 id="添加灯光"><a href="#添加灯光" class="headerlink" title="添加灯光"></a>添加灯光</h2><p>这玩意还没搞懂，先用着最简单的</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const light = new THREE.AmbientLight(0x404040);scene.add(light);</code></pre><h2 id="添加物体"><a href="#添加物体" class="headerlink" title="添加物体"></a>添加物体</h2><p>添加物体四步走：指定物体类型，指定物体材质，创建物体对象，添加物体到场景。以一个棱长为5的正四棱柱为例：</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let geometry = new THREE.BoxGeometry(5, 5, 5);//长宽高let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });let box0 =  new THREE.Mesh(geometry, material);scene.add(box0);</code></pre><p>一般情况下，创建完geometry、material两个变量不会再被使用，所以创建部分也可以写成一句</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">let box0 =  new THREE.Mesh(    new THREE.BoxGeometry(5, 5, 5),     new THREE.MeshBasicMaterial({ color: 0xff0000 }));</code></pre><h2 id="创建渲染器并渲染场景"><a href="#创建渲染器并渲染场景" class="headerlink" title="创建渲染器并渲染场景"></a>创建渲染器并渲染场景</h2><p>这东西也没研究，照抄官方教程。</p><p>需要提前在网页中创建id为”container”的标签来容纳场景。</p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);//渲染的大小就是场景的大小document.getElementById("#container").append(renderer.domElement);renderer.render(scene);</code></pre><p>这几步都完成以后打开网页，就能看见场景和刚才创建的红色四棱柱了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">Three.js documentation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发笔记 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript压缩和混淆</title>
      <link href="/2023/02/55798.html"/>
      <url>/2023/02/55798.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JavaScript压缩和混淆？"><a href="#什么是JavaScript压缩和混淆？" class="headerlink" title="什么是JavaScript压缩和混淆？"></a>什么是JavaScript压缩和混淆？</h2><p>开发人员编写JS代码的时候，有许多格式规范，写出来的代码十分易读、方便开发。<br>而各大网站使用的JS代码，多数都是挤成一团的，肉眼看上去毫无章法可言，可读性几乎为零。</p><p>这些让人“不忍直视”的代码，就是被压缩和混淆过的。一般的压缩通常只是除去注释、空行<br>和空格等，而混淆还会将变量名、函数名等替换成一些无意义的字符，还可能会添加一些<br>无意义的代码。</p><h2 id="如何进行压缩和混淆？"><a href="#如何进行压缩和混淆？" class="headerlink" title="如何进行压缩和混淆？"></a>如何进行压缩和混淆？</h2><p>目前比较流行的混淆工具有Uglify和Google Closure Compiler等。在混淆的<br>过程中，工具还会对代码进行优化，有点类似于C语言编译器的预处理。</p><h2 id="压缩、混淆的作用"><a href="#压缩、混淆的作用" class="headerlink" title="压缩、混淆的作用"></a>压缩、混淆的作用</h2><p>主要是提高JavaScript代码的运行效率，缩小代码体积。一定程度上还可以隐藏代码的运行逻辑<br>起到版权保护的作用。</p><h2 id="随便写写"><a href="#随便写写" class="headerlink" title="随便写写"></a>随便写写</h2><p>个人认为压缩、混淆对代码的保护作用十分有限。如果使用的是一般的混淆方法，<br>很容易就能够还原出大致的框架。部分混淆方法混淆的代码甚至可以完整还原出所有变量名。<br>尽管有些比较“变态”的加密工具，如JavaScript Obfuscator，可以真正做到加密代码，<br>但这最多也就是提高逆向成本罢了。如果真的既要保护代码又非得用JS不可，<br>感觉WebAssembly是个比较好的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日积月累 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
